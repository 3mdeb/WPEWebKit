/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from Automation.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#include <inspector/InspectorProtocolTypes.h>
#include <wtf/Assertions.h>

namespace Inspector {



namespace Protocol {

// Forward declarations.
namespace Automation {
class Point;
class Size;
class Rect;
class BrowsingContext;
class KeyboardInteraction;
class Cookie;
enum class ErrorMessage;
enum class MouseInteraction;
enum class MouseButton;
enum class KeyModifier;
enum class VirtualKey;
enum class KeyboardInteractionType;
} // Automation
// End of forward declarations.


// Typedefs.
namespace Automation {
/* An opaque identifier for a browsing context. */
typedef String BrowsingContextHandle;
/* An opaque identifier for a frame in a page. */
typedef String FrameHandle;
/* An opaque identifier for a node in a page. */
typedef String NodeHandle;
} // Automation
// End of typedefs.

namespace AutomationHelpers {

String getEnumConstantValue(int code);

template<typename T> String getEnumConstantValue(T enumValue)
{
    return getEnumConstantValue(static_cast<int>(enumValue));
}

} // namespace AutomationHelpers

namespace Automation {
class Point : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        XSet = 1 << 0,
        YSet = 1 << 1,
        AllFieldsSet = (XSet | YSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Point*/InspectorObject>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Point;
    public:

        Builder<STATE | XSet>& setX(double value)
        {
            COMPILE_ASSERT(!(STATE & XSet), property_x_already_set);
            m_result->setDouble(ASCIILiteral("x"), value);
            return castState<XSet>();
        }

        Builder<STATE | YSet>& setY(double value)
        {
            COMPILE_ASSERT(!(STATE & YSet), property_y_already_set);
            m_result->setDouble(ASCIILiteral("y"), value);
            return castState<YSet>();
        }

        Ref<Point> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Point) == sizeof(InspectorObject), cannot_cast);

            Ref<InspectorObject> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Point>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Point> result = Point::create()
     *     .setX(...)
     *     .setY(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(InspectorObject::create());
    }
};

class Size : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        WidthSet = 1 << 0,
        HeightSet = 1 << 1,
        AllFieldsSet = (WidthSet | HeightSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Size*/InspectorObject>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Size;
    public:

        Builder<STATE | WidthSet>& setWidth(double value)
        {
            COMPILE_ASSERT(!(STATE & WidthSet), property_width_already_set);
            m_result->setDouble(ASCIILiteral("width"), value);
            return castState<WidthSet>();
        }

        Builder<STATE | HeightSet>& setHeight(double value)
        {
            COMPILE_ASSERT(!(STATE & HeightSet), property_height_already_set);
            m_result->setDouble(ASCIILiteral("height"), value);
            return castState<HeightSet>();
        }

        Ref<Size> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Size) == sizeof(InspectorObject), cannot_cast);

            Ref<InspectorObject> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Size>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Size> result = Size::create()
     *     .setWidth(...)
     *     .setHeight(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(InspectorObject::create());
    }
};

class Rect : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        OriginSet = 1 << 0,
        SizeSet = 1 << 1,
        AllFieldsSet = (OriginSet | SizeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Rect*/InspectorObject>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Rect;
    public:

        Builder<STATE | OriginSet>& setOrigin(RefPtr<Inspector::Protocol::Automation::Point> value)
        {
            COMPILE_ASSERT(!(STATE & OriginSet), property_origin_already_set);
            m_result->setObject(ASCIILiteral("origin"), value);
            return castState<OriginSet>();
        }

        Builder<STATE | SizeSet>& setSize(RefPtr<Inspector::Protocol::Automation::Size> value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setObject(ASCIILiteral("size"), value);
            return castState<SizeSet>();
        }

        Ref<Rect> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Rect) == sizeof(InspectorObject), cannot_cast);

            Ref<InspectorObject> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Rect>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Rect> result = Rect::create()
     *     .setOrigin(...)
     *     .setSize(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(InspectorObject::create());
    }
};

/* This enum contains predefined error messages that can be used to signal a well-defined error condition, such as a missing implementation, unknown window handle, and so forth. The backend signals one of these errors by using it as a prefix of the commands's error message (the errorString argument in generated C++ backend dispatchers). This will be reported to the frontend as a protocol error with a JSON-RPC error code of 'ServerError'. It is up to the frontend whether and how to deal with errors. */
enum class ErrorMessage {
    InternalError = 0,
    Timeout = 1,
    JavaScriptError = 2,
    JavaScriptTimeout = 3,
    WindowNotFound = 4,
    FrameNotFound = 5,
    NodeNotFound = 6,
    NoJavaScriptDialog = 7,
    NotImplemented = 8,
    MissingParameter = 9,
    InvalidParameter = 10,
}; // enum class ErrorMessage
/* A handle representing an open window or tab in the automation session. */
class BrowsingContext : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        HandleSet = 1 << 0,
        ActiveSet = 1 << 1,
        UrlSet = 1 << 2,
        WindowSizeSet = 1 << 3,
        WindowOriginSet = 1 << 4,
        AllFieldsSet = (HandleSet | ActiveSet | UrlSet | WindowSizeSet | WindowOriginSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*BrowsingContext*/InspectorObject>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class BrowsingContext;
    public:

        Builder<STATE | HandleSet>& setHandle(const Inspector::Protocol::Automation::BrowsingContextHandle& value)
        {
            COMPILE_ASSERT(!(STATE & HandleSet), property_handle_already_set);
            m_result->setString(ASCIILiteral("handle"), value);
            return castState<HandleSet>();
        }

        Builder<STATE | ActiveSet>& setActive(bool value)
        {
            COMPILE_ASSERT(!(STATE & ActiveSet), property_active_already_set);
            m_result->setBoolean(ASCIILiteral("active"), value);
            return castState<ActiveSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | WindowSizeSet>& setWindowSize(RefPtr<Inspector::Protocol::Automation::Size> value)
        {
            COMPILE_ASSERT(!(STATE & WindowSizeSet), property_windowSize_already_set);
            m_result->setObject(ASCIILiteral("windowSize"), value);
            return castState<WindowSizeSet>();
        }

        Builder<STATE | WindowOriginSet>& setWindowOrigin(RefPtr<Inspector::Protocol::Automation::Point> value)
        {
            COMPILE_ASSERT(!(STATE & WindowOriginSet), property_windowOrigin_already_set);
            m_result->setObject(ASCIILiteral("windowOrigin"), value);
            return castState<WindowOriginSet>();
        }

        Ref<BrowsingContext> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(BrowsingContext) == sizeof(InspectorObject), cannot_cast);

            Ref<InspectorObject> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<BrowsingContext>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<BrowsingContext> result = BrowsingContext::create()
     *     .setHandle(...)
     *     .setActive(...)
     *     .setUrl(...)
     *     .setWindowSize(...)
     *     .setWindowOrigin(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(InspectorObject::create());
    }
};

/* Enumerates different ways of interacting with a mouse cursor. */
enum class MouseInteraction {
    Move = 11,
    Down = 12,
    Up = 13,
    SingleClick = 14,
    DoubleClick = 15,
}; // enum class MouseInteraction
/* Enumerates different mouse buttons that can be used. */
enum class MouseButton {
    None = 16,
    Left = 17,
    Middle = 18,
    Right = 19,
}; // enum class MouseButton
/* Enumerates different key modifiers that can remain pressed during other mouse/touch interactions. */
enum class KeyModifier {
    CapsLock = 20,
    Control = 21,
    Shift = 22,
    Meta = 23,
    Alt = 24,
}; // enum class KeyModifier
/* Enumerates different platform-independent virtual keys on a physical keyboard whose input via keyboard may or may not produce characters. */
enum class VirtualKey {
    Shift = 22,
    Control = 21,
    Alternate = 25,
    Meta = 23,
    Command = 26,
    Cancel = 27,
    Help = 28,
    Backspace = 29,
    Tab = 30,
    Clear = 31,
    Enter = 32,
    Pause = 33,
    Escape = 34,
    PageUp = 35,
    PageDown = 36,
    End = 37,
    Home = 38,
    LeftArrow = 39,
    UpArrow = 40,
    RightArrow = 41,
    DownArrow = 42,
    Insert = 43,
    Delete = 44,
    Space = 45,
    Semicolon = 46,
    Equals = 47,
    Return = 48,
    NumberPad0 = 49,
    NumberPad1 = 50,
    NumberPad2 = 51,
    NumberPad3 = 52,
    NumberPad4 = 53,
    NumberPad5 = 54,
    NumberPad6 = 55,
    NumberPad7 = 56,
    NumberPad8 = 57,
    NumberPad9 = 58,
    NumberPadMultiply = 59,
    NumberPadAdd = 60,
    NumberPadSeparator = 61,
    NumberPadSubtract = 62,
    NumberPadDecimal = 63,
    NumberPadDivide = 64,
    Function1 = 65,
    Function2 = 66,
    Function3 = 67,
    Function4 = 68,
    Function5 = 69,
    Function6 = 70,
    Function7 = 71,
    Function8 = 72,
    Function9 = 73,
    Function10 = 74,
    Function11 = 75,
    Function12 = 76,
}; // enum class VirtualKey
/* Enumerates different ways of interacting with a keyboard device. 'InsertByKey' implies that a separate KeyDown and KeyUp event are produced for each combining character sequence, regardless of the actual keystrokes required to produce the character sequence. */
enum class KeyboardInteractionType {
    KeyPress = 77,
    KeyRelease = 78,
    InsertByKey = 79,
}; // enum class KeyboardInteractionType
/* A single step in a key sequence. A step can contain a key up/down of a virtual key, or a sequence of Unicode code points that are delivered to the page at grapheme cluster boundaries. Either a 'key' or 'text' property must be specified. */
class KeyboardInteraction : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*KeyboardInteraction*/InspectorObject>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class KeyboardInteraction;
    public:

        Builder<STATE | TypeSet>& setType(Inspector::Protocol::Automation::KeyboardInteractionType value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::AutomationHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Ref<KeyboardInteraction> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(KeyboardInteraction) == sizeof(InspectorObject), cannot_cast);

            Ref<InspectorObject> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<KeyboardInteraction>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<KeyboardInteraction> result = KeyboardInteraction::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(InspectorObject::create());
    }

    void setKey(Inspector::Protocol::Automation::VirtualKey value)
    {
        InspectorObjectBase::setString(ASCIILiteral("key"), Inspector::Protocol::AutomationHelpers::getEnumConstantValue(value));
    }

    void setText(const String& value)
    {
        InspectorObjectBase::setString(ASCIILiteral("text"), value);
    }
};

class Cookie : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        DomainSet = 1 << 2,
        PathSet = 1 << 3,
        ExpiresSet = 1 << 4,
        SizeSet = 1 << 5,
        HttpOnlySet = 1 << 6,
        SecureSet = 1 << 7,
        SessionSet = 1 << 8,
        AllFieldsSet = (NameSet | ValueSet | DomainSet | PathSet | ExpiresSet | SizeSet | HttpOnlySet | SecureSet | SessionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Cookie*/InspectorObject>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Cookie;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DomainSet), property_domain_already_set);
            m_result->setString(ASCIILiteral("domain"), value);
            return castState<DomainSet>();
        }

        Builder<STATE | PathSet>& setPath(const String& value)
        {
            COMPILE_ASSERT(!(STATE & PathSet), property_path_already_set);
            m_result->setString(ASCIILiteral("path"), value);
            return castState<PathSet>();
        }

        Builder<STATE | ExpiresSet>& setExpires(double value)
        {
            COMPILE_ASSERT(!(STATE & ExpiresSet), property_expires_already_set);
            m_result->setDouble(ASCIILiteral("expires"), value);
            return castState<ExpiresSet>();
        }

        Builder<STATE | SizeSet>& setSize(int value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setInteger(ASCIILiteral("size"), value);
            return castState<SizeSet>();
        }

        Builder<STATE | HttpOnlySet>& setHttpOnly(bool value)
        {
            COMPILE_ASSERT(!(STATE & HttpOnlySet), property_httpOnly_already_set);
            m_result->setBoolean(ASCIILiteral("httpOnly"), value);
            return castState<HttpOnlySet>();
        }

        Builder<STATE | SecureSet>& setSecure(bool value)
        {
            COMPILE_ASSERT(!(STATE & SecureSet), property_secure_already_set);
            m_result->setBoolean(ASCIILiteral("secure"), value);
            return castState<SecureSet>();
        }

        Builder<STATE | SessionSet>& setSession(bool value)
        {
            COMPILE_ASSERT(!(STATE & SessionSet), property_session_already_set);
            m_result->setBoolean(ASCIILiteral("session"), value);
            return castState<SessionSet>();
        }

        Ref<Cookie> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Cookie) == sizeof(InspectorObject), cannot_cast);

            Ref<InspectorObject> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Cookie>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Cookie> result = Cookie::create()
     *     .setName(...)
     *     .setValue(...)
     *     .setDomain(...)
     *     .setPath(...)
     *     .setExpires(...)
     *     .setSize(...)
     *     .setHttpOnly(...)
     *     .setSecure(...)
     *     .setSession(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(InspectorObject::create());
    }
};

} // Automation



namespace AutomationHelpers {

template<typename ProtocolEnumType>
Optional<ProtocolEnumType> parseEnumValueFromString(const String&);

// Enums in the 'Automation' Domain
template<>
Optional<Inspector::Protocol::Automation::ErrorMessage> parseEnumValueFromString<Inspector::Protocol::Automation::ErrorMessage>(const String&);
template<>
Optional<Inspector::Protocol::Automation::MouseInteraction> parseEnumValueFromString<Inspector::Protocol::Automation::MouseInteraction>(const String&);
template<>
Optional<Inspector::Protocol::Automation::MouseButton> parseEnumValueFromString<Inspector::Protocol::Automation::MouseButton>(const String&);
template<>
Optional<Inspector::Protocol::Automation::KeyModifier> parseEnumValueFromString<Inspector::Protocol::Automation::KeyModifier>(const String&);
template<>
Optional<Inspector::Protocol::Automation::VirtualKey> parseEnumValueFromString<Inspector::Protocol::Automation::VirtualKey>(const String&);
template<>
Optional<Inspector::Protocol::Automation::KeyboardInteractionType> parseEnumValueFromString<Inspector::Protocol::Automation::KeyboardInteractionType>(const String&);

} // namespace AutomationHelpers

} // namespace Protocol

} // namespace Inspector
