/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"
#include "JSSVGElement.h"

#include "CSSValue.h"
#include "EventNames.h"
#include "ExceptionCode.h"
#include "JSCSSStyleDeclaration.h"
#include "JSCSSValue.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructor.h"
#include "JSDOMConvert.h"
#include "JSDOMStringMap.h"
#include "JSEventListener.h"
#include "JSSVGAnimatedString.h"
#include "JSSVGElement.h"
#include "JSSVGSVGElement.h"
#include "StyleProperties.h"
#include "URL.h"
#include <runtime/Error.h>
#include <runtime/JSString.h>
#include <wtf/GetPtr.h>

using namespace JSC;

namespace WebCore {

// Functions

JSC::EncodedJSValue JSC_HOST_CALL jsSVGElementPrototypeFunctionGetPresentationAttribute(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGElementPrototypeFunctionFocus(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsSVGElementPrototypeFunctionBlur(JSC::ExecState*);

// Attributes

JSC::EncodedJSValue jsSVGElementOwnerSVGElement(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGElementViewportElement(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGElementXmllang(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementXmllang(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementXmlspace(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementXmlspace(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementClassName(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGElementStyle(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGElementTabIndex(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementTabIndex(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementDataset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsSVGElementOnabort(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnabort(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(REQUEST_AUTOCOMPLETE)
JSC::EncodedJSValue jsSVGElementOnautocomplete(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnautocomplete(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(REQUEST_AUTOCOMPLETE)
JSC::EncodedJSValue jsSVGElementOnautocompleteerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnautocompleteerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
JSC::EncodedJSValue jsSVGElementOnblur(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnblur(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOncanplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOncanplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOncanplaythrough(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOncanplaythrough(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOncontextmenu(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOncontextmenu(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOncuechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOncuechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOndblclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOndblclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOndrag(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOndrag(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOndragend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOndragend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOndragenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOndragenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOndragleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOndragleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOndragover(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOndragover(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOndragstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOndragstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOndrop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOndrop(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOndurationchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOndurationchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnemptied(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnemptied(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnended(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnended(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnfocus(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnfocus(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOninput(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOninput(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOninvalid(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOninvalid(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnkeydown(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnkeydown(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnkeypress(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnkeypress(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnkeyup(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnkeyup(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnload(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnload(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnloadeddata(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnloadeddata(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnloadedmetadata(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnloadedmetadata(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnloadstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnloadstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnmousedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnmousedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnmouseenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnmouseenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnmouseleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnmouseleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnmousemove(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnmousemove(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnmouseout(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnmouseout(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnmouseover(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnmouseover(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnmouseup(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnmouseup(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnmousewheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnmousewheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnpause(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnpause(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnplaying(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnplaying(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnprogress(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnprogress(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnratechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnratechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnreset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnreset(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnresize(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnresize(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnscroll(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnscroll(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnseeked(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnseeked(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnseeking(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnseeking(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnselect(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnselect(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnstalled(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnstalled(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnsubmit(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnsubmit(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnsuspend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnsuspend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOntimeupdate(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOntimeupdate(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnvolumechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnvolumechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnwaiting(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnwaiting(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnsearch(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnsearch(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsSVGElementOnwheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnwheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(TOUCH_EVENTS)
JSC::EncodedJSValue jsSVGElementOntouchcancel(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOntouchcancel(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(TOUCH_EVENTS)
JSC::EncodedJSValue jsSVGElementOntouchend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOntouchend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(TOUCH_EVENTS)
JSC::EncodedJSValue jsSVGElementOntouchmove(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOntouchmove(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(TOUCH_EVENTS)
JSC::EncodedJSValue jsSVGElementOntouchstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOntouchstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(TOUCH_EVENTS)
JSC::EncodedJSValue jsSVGElementOntouchforcechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOntouchforcechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(MOUSE_FORCE_EVENTS)
JSC::EncodedJSValue jsSVGElementOnwebkitmouseforcechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnwebkitmouseforcechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(MOUSE_FORCE_EVENTS)
JSC::EncodedJSValue jsSVGElementOnwebkitmouseforcedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnwebkitmouseforcedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(MOUSE_FORCE_EVENTS)
JSC::EncodedJSValue jsSVGElementOnwebkitmouseforcewillbegin(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnwebkitmouseforcewillbegin(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(MOUSE_FORCE_EVENTS)
JSC::EncodedJSValue jsSVGElementOnwebkitmouseforceup(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnwebkitmouseforceup(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
JSC::EncodedJSValue jsSVGElementOnwebkitwillrevealbottom(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnwebkitwillrevealbottom(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
JSC::EncodedJSValue jsSVGElementOnwebkitwillrevealleft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnwebkitwillrevealleft(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
JSC::EncodedJSValue jsSVGElementOnwebkitwillrevealright(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnwebkitwillrevealright(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
JSC::EncodedJSValue jsSVGElementOnwebkitwillrevealtop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementOnwebkitwillrevealtop(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
JSC::EncodedJSValue jsSVGElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSSVGElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);

class JSSVGElementPrototype : public JSC::JSNonFinalObject {
public:
    typedef JSC::JSNonFinalObject Base;
    static JSSVGElementPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSSVGElementPrototype* ptr = new (NotNull, JSC::allocateCell<JSSVGElementPrototype>(vm.heap)) JSSVGElementPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSSVGElementPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};

typedef JSDOMConstructorNotConstructable<JSSVGElement> JSSVGElementConstructor;

template<> JSValue JSSVGElementConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    return JSElement::getConstructor(vm, &globalObject);
}

template<> void JSSVGElementConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->prototype, JSSVGElement::prototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("SVGElement"))), ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
}

template<> const ClassInfo JSSVGElementConstructor::s_info = { "SVGElement", &Base::s_info, 0, CREATE_METHOD_TABLE(JSSVGElementConstructor) };

/* Hash table for prototype */

static const HashTableValue JSSVGElementPrototypeTableValues[] =
{
    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementConstructor) } },
    { "ownerSVGElement", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOwnerSVGElement), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "viewportElement", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementViewportElement), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "xmllang", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementXmllang), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementXmllang) } },
    { "xmlspace", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementXmlspace), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementXmlspace) } },
    { "className", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementClassName), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "style", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementStyle), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "tabIndex", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementTabIndex), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementTabIndex) } },
    { "dataset", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementDataset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "onabort", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnabort), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnabort) } },
#if ENABLE(REQUEST_AUTOCOMPLETE)
    { "onautocomplete", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnautocomplete), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnautocomplete) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(REQUEST_AUTOCOMPLETE)
    { "onautocompleteerror", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnautocompleteerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnautocompleteerror) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "onblur", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnblur), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnblur) } },
    { "oncanplay", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOncanplay), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOncanplay) } },
    { "oncanplaythrough", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOncanplaythrough), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOncanplaythrough) } },
    { "onchange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnchange) } },
    { "onclick", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnclick), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnclick) } },
    { "oncontextmenu", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOncontextmenu), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOncontextmenu) } },
    { "oncuechange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOncuechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOncuechange) } },
    { "ondblclick", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOndblclick), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOndblclick) } },
    { "ondrag", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOndrag), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOndrag) } },
    { "ondragend", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOndragend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOndragend) } },
    { "ondragenter", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOndragenter), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOndragenter) } },
    { "ondragleave", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOndragleave), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOndragleave) } },
    { "ondragover", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOndragover), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOndragover) } },
    { "ondragstart", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOndragstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOndragstart) } },
    { "ondrop", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOndrop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOndrop) } },
    { "ondurationchange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOndurationchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOndurationchange) } },
    { "onemptied", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnemptied), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnemptied) } },
    { "onended", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnended), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnended) } },
    { "onerror", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnerror) } },
    { "onfocus", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnfocus), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnfocus) } },
    { "oninput", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOninput), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOninput) } },
    { "oninvalid", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOninvalid), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOninvalid) } },
    { "onkeydown", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnkeydown), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnkeydown) } },
    { "onkeypress", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnkeypress), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnkeypress) } },
    { "onkeyup", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnkeyup), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnkeyup) } },
    { "onload", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnload), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnload) } },
    { "onloadeddata", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnloadeddata), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnloadeddata) } },
    { "onloadedmetadata", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnloadedmetadata), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnloadedmetadata) } },
    { "onloadstart", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnloadstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnloadstart) } },
    { "onmousedown", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnmousedown), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnmousedown) } },
    { "onmouseenter", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnmouseenter), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnmouseenter) } },
    { "onmouseleave", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnmouseleave), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnmouseleave) } },
    { "onmousemove", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnmousemove), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnmousemove) } },
    { "onmouseout", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnmouseout), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnmouseout) } },
    { "onmouseover", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnmouseover), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnmouseover) } },
    { "onmouseup", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnmouseup), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnmouseup) } },
    { "onmousewheel", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnmousewheel), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnmousewheel) } },
    { "onpause", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnpause), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnpause) } },
    { "onplay", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnplay), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnplay) } },
    { "onplaying", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnplaying), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnplaying) } },
    { "onprogress", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnprogress), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnprogress) } },
    { "onratechange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnratechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnratechange) } },
    { "onreset", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnreset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnreset) } },
    { "onresize", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnresize), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnresize) } },
    { "onscroll", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnscroll), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnscroll) } },
    { "onseeked", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnseeked), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnseeked) } },
    { "onseeking", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnseeking), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnseeking) } },
    { "onselect", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnselect), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnselect) } },
    { "onstalled", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnstalled), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnstalled) } },
    { "onsubmit", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnsubmit), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnsubmit) } },
    { "onsuspend", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnsuspend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnsuspend) } },
    { "ontimeupdate", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOntimeupdate), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOntimeupdate) } },
    { "onvolumechange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnvolumechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnvolumechange) } },
    { "onwaiting", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnwaiting), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnwaiting) } },
    { "onsearch", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnsearch), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnsearch) } },
    { "onwheel", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnwheel), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnwheel) } },
#if ENABLE(TOUCH_EVENTS)
    { "ontouchcancel", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOntouchcancel), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOntouchcancel) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(TOUCH_EVENTS)
    { "ontouchend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOntouchend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOntouchend) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(TOUCH_EVENTS)
    { "ontouchmove", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOntouchmove), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOntouchmove) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(TOUCH_EVENTS)
    { "ontouchstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOntouchstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOntouchstart) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(TOUCH_EVENTS)
    { "ontouchforcechange", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOntouchforcechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOntouchforcechange) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(MOUSE_FORCE_EVENTS)
    { "onwebkitmouseforcechanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnwebkitmouseforcechanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnwebkitmouseforcechanged) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(MOUSE_FORCE_EVENTS)
    { "onwebkitmouseforcedown", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnwebkitmouseforcedown), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnwebkitmouseforcedown) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(MOUSE_FORCE_EVENTS)
    { "onwebkitmouseforcewillbegin", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnwebkitmouseforcewillbegin), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnwebkitmouseforcewillbegin) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(MOUSE_FORCE_EVENTS)
    { "onwebkitmouseforceup", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnwebkitmouseforceup), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnwebkitmouseforceup) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
    { "onwebkitwillrevealbottom", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnwebkitwillrevealbottom), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnwebkitwillrevealbottom) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
    { "onwebkitwillrevealleft", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnwebkitwillrevealleft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnwebkitwillrevealleft) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
    { "onwebkitwillrevealright", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnwebkitwillrevealright), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnwebkitwillrevealright) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
    { "onwebkitwillrevealtop", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsSVGElementOnwebkitwillrevealtop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSSVGElementOnwebkitwillrevealtop) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "getPresentationAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGElementPrototypeFunctionGetPresentationAttribute), (intptr_t) (0) } },
    { "focus", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGElementPrototypeFunctionFocus), (intptr_t) (0) } },
    { "blur", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsSVGElementPrototypeFunctionBlur), (intptr_t) (0) } },
};

const ClassInfo JSSVGElementPrototype::s_info = { "SVGElementPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSSVGElementPrototype) };

void JSSVGElementPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSSVGElementPrototypeTableValues, *this);
}

const ClassInfo JSSVGElement::s_info = { "SVGElement", &Base::s_info, 0, CREATE_METHOD_TABLE(JSSVGElement) };

JSSVGElement::JSSVGElement(Structure* structure, JSDOMGlobalObject& globalObject, Ref<SVGElement>&& impl)
    : JSElement(structure, globalObject, WTFMove(impl))
{
}

JSObject* JSSVGElement::createPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return JSSVGElementPrototype::create(vm, globalObject, JSSVGElementPrototype::createStructure(vm, globalObject, JSElement::prototype(vm, globalObject)));
}

JSObject* JSSVGElement::prototype(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSSVGElement>(vm, globalObject);
}

EncodedJSValue jsSVGElementOwnerSVGElement(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ownerSVGElement");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.ownerSVGElement());
    return JSValue::encode(result);
}


EncodedJSValue jsSVGElementViewportElement(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "viewportElement");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.viewportElement());
    return JSValue::encode(result);
}


EncodedJSValue jsSVGElementXmllang(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "xmllang");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.xmllang());
    return JSValue::encode(result);
}


EncodedJSValue jsSVGElementXmlspace(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "xmlspace");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.xmlspace());
    return JSValue::encode(result);
}


EncodedJSValue jsSVGElementClassName(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "className");
    }
    auto& impl = castedThis->wrapped();
    auto obj = impl.classNameAnimated();
    JSValue result = toJS(state, castedThis->globalObject(), obj.get());
    return JSValue::encode(result);
}


EncodedJSValue jsSVGElementStyle(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "style");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.cssomStyle());
    return JSValue::encode(result);
}


EncodedJSValue jsSVGElementTabIndex(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "tabIndex");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.tabIndex());
    return JSValue::encode(result);
}


EncodedJSValue jsSVGElementDataset(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "dataset");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.dataset());
    return JSValue::encode(result);
}


EncodedJSValue jsSVGElementOnabort(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onabort");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().abortEvent));
}


#if ENABLE(REQUEST_AUTOCOMPLETE)
EncodedJSValue jsSVGElementOnautocomplete(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onautocomplete");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().autocompleteEvent));
}

#endif

#if ENABLE(REQUEST_AUTOCOMPLETE)
EncodedJSValue jsSVGElementOnautocompleteerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onautocompleteerror");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().autocompleteerrorEvent));
}

#endif

EncodedJSValue jsSVGElementOnblur(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onblur");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().blurEvent));
}


EncodedJSValue jsSVGElementOncanplay(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "oncanplay");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().canplayEvent));
}


EncodedJSValue jsSVGElementOncanplaythrough(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "oncanplaythrough");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().canplaythroughEvent));
}


EncodedJSValue jsSVGElementOnchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onchange");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().changeEvent));
}


EncodedJSValue jsSVGElementOnclick(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onclick");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().clickEvent));
}


EncodedJSValue jsSVGElementOncontextmenu(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "oncontextmenu");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().contextmenuEvent));
}


EncodedJSValue jsSVGElementOncuechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "oncuechange");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().cuechangeEvent));
}


EncodedJSValue jsSVGElementOndblclick(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ondblclick");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dblclickEvent));
}


EncodedJSValue jsSVGElementOndrag(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ondrag");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragEvent));
}


EncodedJSValue jsSVGElementOndragend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ondragend");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragendEvent));
}


EncodedJSValue jsSVGElementOndragenter(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ondragenter");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragenterEvent));
}


EncodedJSValue jsSVGElementOndragleave(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ondragleave");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragleaveEvent));
}


EncodedJSValue jsSVGElementOndragover(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ondragover");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragoverEvent));
}


EncodedJSValue jsSVGElementOndragstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ondragstart");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragstartEvent));
}


EncodedJSValue jsSVGElementOndrop(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ondrop");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dropEvent));
}


EncodedJSValue jsSVGElementOndurationchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ondurationchange");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().durationchangeEvent));
}


EncodedJSValue jsSVGElementOnemptied(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onemptied");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().emptiedEvent));
}


EncodedJSValue jsSVGElementOnended(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onended");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().endedEvent));
}


EncodedJSValue jsSVGElementOnerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onerror");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().errorEvent));
}


EncodedJSValue jsSVGElementOnfocus(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onfocus");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().focusEvent));
}


EncodedJSValue jsSVGElementOninput(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "oninput");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().inputEvent));
}


EncodedJSValue jsSVGElementOninvalid(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "oninvalid");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().invalidEvent));
}


EncodedJSValue jsSVGElementOnkeydown(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onkeydown");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().keydownEvent));
}


EncodedJSValue jsSVGElementOnkeypress(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onkeypress");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().keypressEvent));
}


EncodedJSValue jsSVGElementOnkeyup(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onkeyup");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().keyupEvent));
}


EncodedJSValue jsSVGElementOnload(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onload");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadEvent));
}


EncodedJSValue jsSVGElementOnloadeddata(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onloadeddata");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadeddataEvent));
}


EncodedJSValue jsSVGElementOnloadedmetadata(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onloadedmetadata");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadedmetadataEvent));
}


EncodedJSValue jsSVGElementOnloadstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onloadstart");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadstartEvent));
}


EncodedJSValue jsSVGElementOnmousedown(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onmousedown");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mousedownEvent));
}


EncodedJSValue jsSVGElementOnmouseenter(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return JSValue::encode(jsUndefined());
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseenterEvent));
}


EncodedJSValue jsSVGElementOnmouseleave(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return JSValue::encode(jsUndefined());
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseleaveEvent));
}


EncodedJSValue jsSVGElementOnmousemove(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onmousemove");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mousemoveEvent));
}


EncodedJSValue jsSVGElementOnmouseout(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onmouseout");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseoutEvent));
}


EncodedJSValue jsSVGElementOnmouseover(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onmouseover");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseoverEvent));
}


EncodedJSValue jsSVGElementOnmouseup(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onmouseup");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseupEvent));
}


EncodedJSValue jsSVGElementOnmousewheel(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onmousewheel");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mousewheelEvent));
}


EncodedJSValue jsSVGElementOnpause(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onpause");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().pauseEvent));
}


EncodedJSValue jsSVGElementOnplay(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onplay");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().playEvent));
}


EncodedJSValue jsSVGElementOnplaying(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onplaying");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().playingEvent));
}


EncodedJSValue jsSVGElementOnprogress(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onprogress");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().progressEvent));
}


EncodedJSValue jsSVGElementOnratechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onratechange");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().ratechangeEvent));
}


EncodedJSValue jsSVGElementOnreset(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onreset");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().resetEvent));
}


EncodedJSValue jsSVGElementOnresize(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onresize");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().resizeEvent));
}


EncodedJSValue jsSVGElementOnscroll(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onscroll");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().scrollEvent));
}


EncodedJSValue jsSVGElementOnseeked(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onseeked");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().seekedEvent));
}


EncodedJSValue jsSVGElementOnseeking(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onseeking");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().seekingEvent));
}


EncodedJSValue jsSVGElementOnselect(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onselect");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().selectEvent));
}


EncodedJSValue jsSVGElementOnstalled(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onstalled");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().stalledEvent));
}


EncodedJSValue jsSVGElementOnsubmit(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onsubmit");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().submitEvent));
}


EncodedJSValue jsSVGElementOnsuspend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onsuspend");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().suspendEvent));
}


EncodedJSValue jsSVGElementOntimeupdate(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ontimeupdate");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().timeupdateEvent));
}


EncodedJSValue jsSVGElementOnvolumechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onvolumechange");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().volumechangeEvent));
}


EncodedJSValue jsSVGElementOnwaiting(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onwaiting");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().waitingEvent));
}


EncodedJSValue jsSVGElementOnsearch(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onsearch");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().searchEvent));
}


EncodedJSValue jsSVGElementOnwheel(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onwheel");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().wheelEvent));
}


#if ENABLE(TOUCH_EVENTS)
EncodedJSValue jsSVGElementOntouchcancel(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ontouchcancel");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchcancelEvent));
}

#endif

#if ENABLE(TOUCH_EVENTS)
EncodedJSValue jsSVGElementOntouchend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ontouchend");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchendEvent));
}

#endif

#if ENABLE(TOUCH_EVENTS)
EncodedJSValue jsSVGElementOntouchmove(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ontouchmove");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchmoveEvent));
}

#endif

#if ENABLE(TOUCH_EVENTS)
EncodedJSValue jsSVGElementOntouchstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ontouchstart");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchstartEvent));
}

#endif

#if ENABLE(TOUCH_EVENTS)
EncodedJSValue jsSVGElementOntouchforcechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "ontouchforcechange");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchforcechangeEvent));
}

#endif

#if ENABLE(MOUSE_FORCE_EVENTS)
EncodedJSValue jsSVGElementOnwebkitmouseforcechanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onwebkitmouseforcechanged");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforcechangedEvent));
}

#endif

#if ENABLE(MOUSE_FORCE_EVENTS)
EncodedJSValue jsSVGElementOnwebkitmouseforcedown(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onwebkitmouseforcedown");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforcedownEvent));
}

#endif

#if ENABLE(MOUSE_FORCE_EVENTS)
EncodedJSValue jsSVGElementOnwebkitmouseforcewillbegin(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onwebkitmouseforcewillbegin");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforcewillbeginEvent));
}

#endif

#if ENABLE(MOUSE_FORCE_EVENTS)
EncodedJSValue jsSVGElementOnwebkitmouseforceup(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onwebkitmouseforceup");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforceupEvent));
}

#endif

#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
EncodedJSValue jsSVGElementOnwebkitwillrevealbottom(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onwebkitwillrevealbottom");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealbottomEvent));
}

#endif

#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
EncodedJSValue jsSVGElementOnwebkitwillrevealleft(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onwebkitwillrevealleft");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealleftEvent));
}

#endif

#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
EncodedJSValue jsSVGElementOnwebkitwillrevealright(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onwebkitwillrevealright");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealrightEvent));
}

#endif

#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
EncodedJSValue jsSVGElementOnwebkitwillrevealtop(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSSVGElement*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "SVGElement", "onwebkitwillrevealtop");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealtopEvent));
}

#endif

EncodedJSValue jsSVGElementConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    JSSVGElementPrototype* domObject = jsDynamicCast<JSSVGElementPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject))
        return throwVMTypeError(state);
    return JSValue::encode(JSSVGElement::getConstructor(state->vm(), domObject->globalObject()));
}

bool setJSSVGElementConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    JSSVGElementPrototype* domObject = jsDynamicCast<JSSVGElementPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject)) {
        throwVMTypeError(state);
        return false;
    }
    // Shadowing a built-in constructor
    return domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
}

bool setJSSVGElementXmllang(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "xmllang");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setXmllang(WTFMove(nativeValue));
    return true;
}


bool setJSSVGElementXmlspace(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "xmlspace");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setXmlspace(WTFMove(nativeValue));
    return true;
}


bool setJSSVGElementTabIndex(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "tabIndex");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = convert<int32_t>(*state, value, NormalConversion);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setTabIndex(WTFMove(nativeValue));
    return true;
}


bool setJSSVGElementOnabort(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onabort");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().abortEvent, value);
    return true;
}


#if ENABLE(REQUEST_AUTOCOMPLETE)
bool setJSSVGElementOnautocomplete(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onautocomplete");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().autocompleteEvent, value);
    return true;
}

#endif

#if ENABLE(REQUEST_AUTOCOMPLETE)
bool setJSSVGElementOnautocompleteerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onautocompleteerror");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().autocompleteerrorEvent, value);
    return true;
}

#endif

bool setJSSVGElementOnblur(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onblur");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().blurEvent, value);
    return true;
}


bool setJSSVGElementOncanplay(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "oncanplay");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().canplayEvent, value);
    return true;
}


bool setJSSVGElementOncanplaythrough(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "oncanplaythrough");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().canplaythroughEvent, value);
    return true;
}


bool setJSSVGElementOnchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onchange");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().changeEvent, value);
    return true;
}


bool setJSSVGElementOnclick(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onclick");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().clickEvent, value);
    return true;
}


bool setJSSVGElementOncontextmenu(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "oncontextmenu");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().contextmenuEvent, value);
    return true;
}


bool setJSSVGElementOncuechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "oncuechange");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().cuechangeEvent, value);
    return true;
}


bool setJSSVGElementOndblclick(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ondblclick");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dblclickEvent, value);
    return true;
}


bool setJSSVGElementOndrag(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ondrag");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragEvent, value);
    return true;
}


bool setJSSVGElementOndragend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ondragend");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragendEvent, value);
    return true;
}


bool setJSSVGElementOndragenter(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ondragenter");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragenterEvent, value);
    return true;
}


bool setJSSVGElementOndragleave(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ondragleave");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragleaveEvent, value);
    return true;
}


bool setJSSVGElementOndragover(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ondragover");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragoverEvent, value);
    return true;
}


bool setJSSVGElementOndragstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ondragstart");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragstartEvent, value);
    return true;
}


bool setJSSVGElementOndrop(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ondrop");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dropEvent, value);
    return true;
}


bool setJSSVGElementOndurationchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ondurationchange");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().durationchangeEvent, value);
    return true;
}


bool setJSSVGElementOnemptied(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onemptied");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().emptiedEvent, value);
    return true;
}


bool setJSSVGElementOnended(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onended");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().endedEvent, value);
    return true;
}


bool setJSSVGElementOnerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onerror");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().errorEvent, value);
    return true;
}


bool setJSSVGElementOnfocus(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onfocus");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().focusEvent, value);
    return true;
}


bool setJSSVGElementOninput(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "oninput");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().inputEvent, value);
    return true;
}


bool setJSSVGElementOninvalid(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "oninvalid");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().invalidEvent, value);
    return true;
}


bool setJSSVGElementOnkeydown(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onkeydown");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().keydownEvent, value);
    return true;
}


bool setJSSVGElementOnkeypress(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onkeypress");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().keypressEvent, value);
    return true;
}


bool setJSSVGElementOnkeyup(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onkeyup");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().keyupEvent, value);
    return true;
}


bool setJSSVGElementOnload(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onload");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadEvent, value);
    return true;
}


bool setJSSVGElementOnloadeddata(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onloadeddata");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadeddataEvent, value);
    return true;
}


bool setJSSVGElementOnloadedmetadata(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onloadedmetadata");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadedmetadataEvent, value);
    return true;
}


bool setJSSVGElementOnloadstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onloadstart");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadstartEvent, value);
    return true;
}


bool setJSSVGElementOnmousedown(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onmousedown");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mousedownEvent, value);
    return true;
}


bool setJSSVGElementOnmouseenter(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return false;
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseenterEvent, value);
    return true;
}


bool setJSSVGElementOnmouseleave(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return false;
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseleaveEvent, value);
    return true;
}


bool setJSSVGElementOnmousemove(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onmousemove");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mousemoveEvent, value);
    return true;
}


bool setJSSVGElementOnmouseout(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onmouseout");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseoutEvent, value);
    return true;
}


bool setJSSVGElementOnmouseover(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onmouseover");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseoverEvent, value);
    return true;
}


bool setJSSVGElementOnmouseup(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onmouseup");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseupEvent, value);
    return true;
}


bool setJSSVGElementOnmousewheel(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onmousewheel");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mousewheelEvent, value);
    return true;
}


bool setJSSVGElementOnpause(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onpause");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().pauseEvent, value);
    return true;
}


bool setJSSVGElementOnplay(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onplay");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().playEvent, value);
    return true;
}


bool setJSSVGElementOnplaying(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onplaying");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().playingEvent, value);
    return true;
}


bool setJSSVGElementOnprogress(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onprogress");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().progressEvent, value);
    return true;
}


bool setJSSVGElementOnratechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onratechange");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().ratechangeEvent, value);
    return true;
}


bool setJSSVGElementOnreset(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onreset");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().resetEvent, value);
    return true;
}


bool setJSSVGElementOnresize(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onresize");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().resizeEvent, value);
    return true;
}


bool setJSSVGElementOnscroll(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onscroll");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().scrollEvent, value);
    return true;
}


bool setJSSVGElementOnseeked(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onseeked");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().seekedEvent, value);
    return true;
}


bool setJSSVGElementOnseeking(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onseeking");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().seekingEvent, value);
    return true;
}


bool setJSSVGElementOnselect(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onselect");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().selectEvent, value);
    return true;
}


bool setJSSVGElementOnstalled(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onstalled");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().stalledEvent, value);
    return true;
}


bool setJSSVGElementOnsubmit(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onsubmit");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().submitEvent, value);
    return true;
}


bool setJSSVGElementOnsuspend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onsuspend");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().suspendEvent, value);
    return true;
}


bool setJSSVGElementOntimeupdate(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ontimeupdate");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().timeupdateEvent, value);
    return true;
}


bool setJSSVGElementOnvolumechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onvolumechange");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().volumechangeEvent, value);
    return true;
}


bool setJSSVGElementOnwaiting(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onwaiting");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().waitingEvent, value);
    return true;
}


bool setJSSVGElementOnsearch(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onsearch");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().searchEvent, value);
    return true;
}


bool setJSSVGElementOnwheel(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onwheel");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().wheelEvent, value);
    return true;
}


#if ENABLE(TOUCH_EVENTS)
bool setJSSVGElementOntouchcancel(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ontouchcancel");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchcancelEvent, value);
    return true;
}

#endif

#if ENABLE(TOUCH_EVENTS)
bool setJSSVGElementOntouchend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ontouchend");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchendEvent, value);
    return true;
}

#endif

#if ENABLE(TOUCH_EVENTS)
bool setJSSVGElementOntouchmove(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ontouchmove");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchmoveEvent, value);
    return true;
}

#endif

#if ENABLE(TOUCH_EVENTS)
bool setJSSVGElementOntouchstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ontouchstart");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchstartEvent, value);
    return true;
}

#endif

#if ENABLE(TOUCH_EVENTS)
bool setJSSVGElementOntouchforcechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "ontouchforcechange");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchforcechangeEvent, value);
    return true;
}

#endif

#if ENABLE(MOUSE_FORCE_EVENTS)
bool setJSSVGElementOnwebkitmouseforcechanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onwebkitmouseforcechanged");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforcechangedEvent, value);
    return true;
}

#endif

#if ENABLE(MOUSE_FORCE_EVENTS)
bool setJSSVGElementOnwebkitmouseforcedown(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onwebkitmouseforcedown");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforcedownEvent, value);
    return true;
}

#endif

#if ENABLE(MOUSE_FORCE_EVENTS)
bool setJSSVGElementOnwebkitmouseforcewillbegin(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onwebkitmouseforcewillbegin");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforcewillbeginEvent, value);
    return true;
}

#endif

#if ENABLE(MOUSE_FORCE_EVENTS)
bool setJSSVGElementOnwebkitmouseforceup(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onwebkitmouseforceup");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforceupEvent, value);
    return true;
}

#endif

#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
bool setJSSVGElementOnwebkitwillrevealbottom(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onwebkitwillrevealbottom");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealbottomEvent, value);
    return true;
}

#endif

#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
bool setJSSVGElementOnwebkitwillrevealleft(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onwebkitwillrevealleft");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealleftEvent, value);
    return true;
}

#endif

#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
bool setJSSVGElementOnwebkitwillrevealright(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onwebkitwillrevealright");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealrightEvent, value);
    return true;
}

#endif

#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
bool setJSSVGElementOnwebkitwillrevealtop(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSSVGElement* castedThis = jsDynamicCast<JSSVGElement*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "SVGElement", "onwebkitwillrevealtop");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealtopEvent, value);
    return true;
}

#endif

JSValue JSSVGElement::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSSVGElementConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

EncodedJSValue JSC_HOST_CALL jsSVGElementPrototypeFunctionGetPresentationAttribute(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSSVGElement*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "SVGElement", "getPresentationAttribute");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSSVGElement::info());
    auto& impl = castedThis->wrapped();
    auto name = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getPresentationAttribute(WTFMove(name)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsSVGElementPrototypeFunctionFocus(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSSVGElement*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "SVGElement", "focus");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSSVGElement::info());
    auto& impl = castedThis->wrapped();
    impl.focus();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsSVGElementPrototypeFunctionBlur(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSSVGElement*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "SVGElement", "blur");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSSVGElement::info());
    auto& impl = castedThis->wrapped();
    impl.blur();
    return JSValue::encode(jsUndefined());
}

void JSSVGElement::visitChildren(JSCell* cell, SlotVisitor& visitor)
{
    auto* thisObject = jsCast<JSSVGElement*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    thisObject->wrapped().visitJSEventListeners(visitor);
}

SVGElement* JSSVGElement::toWrapped(JSC::JSValue value)
{
    if (auto* wrapper = jsDynamicCast<JSSVGElement*>(value))
        return &wrapper->wrapped();
    return nullptr;
}

}
