/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from Automation.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#include "AutomationProtocolObjects.h"
#include <inspector/InspectorBackendDispatcher.h>
#include <wtf/text/WTFString.h>

namespace Inspector {

typedef String ErrorString;

class AutomationBackendDispatcherHandler {
public:
    virtual void getBrowsingContexts(ErrorString&, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Automation::BrowsingContext>>& out_contexts) = 0;
    virtual void getBrowsingContext(ErrorString&, const String& in_handle, RefPtr<Inspector::Protocol::Automation::BrowsingContext>& out_context) = 0;
    virtual void createBrowsingContext(ErrorString&, String* out_handle) = 0;
    virtual void closeBrowsingContext(ErrorString&, const String& in_handle) = 0;
    virtual void switchToBrowsingContext(ErrorString&, const String& in_browsingContextHandle, const String* opt_in_frameHandle) = 0;
    virtual void resizeWindowOfBrowsingContext(ErrorString&, const String& in_handle, const Inspector::InspectorObject& in_size) = 0;
    virtual void moveWindowOfBrowsingContext(ErrorString&, const String& in_handle, const Inspector::InspectorObject& in_origin) = 0;
    class NavigateBrowsingContextCallback : public BackendDispatcher::CallbackBase {
    public:
        NavigateBrowsingContextCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess();
    };
    virtual void navigateBrowsingContext(ErrorString&, const String& in_handle, const String& in_url, Ref<NavigateBrowsingContextCallback>&& callback) = 0;
    class GoBackInBrowsingContextCallback : public BackendDispatcher::CallbackBase {
    public:
        GoBackInBrowsingContextCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess();
    };
    virtual void goBackInBrowsingContext(ErrorString&, const String& in_handle, Ref<GoBackInBrowsingContextCallback>&& callback) = 0;
    class GoForwardInBrowsingContextCallback : public BackendDispatcher::CallbackBase {
    public:
        GoForwardInBrowsingContextCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess();
    };
    virtual void goForwardInBrowsingContext(ErrorString&, const String& in_handle, Ref<GoForwardInBrowsingContextCallback>&& callback) = 0;
    class ReloadBrowsingContextCallback : public BackendDispatcher::CallbackBase {
    public:
        ReloadBrowsingContextCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess();
    };
    virtual void reloadBrowsingContext(ErrorString&, const String& in_handle, Ref<ReloadBrowsingContextCallback>&& callback) = 0;
    class InspectBrowsingContextCallback : public BackendDispatcher::CallbackBase {
    public:
        InspectBrowsingContextCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess();
    };
    virtual void inspectBrowsingContext(ErrorString&, const String& in_handle, Ref<InspectBrowsingContextCallback>&& callback) = 0;
    class EvaluateJavaScriptFunctionCallback : public BackendDispatcher::CallbackBase {
    public:
        EvaluateJavaScriptFunctionCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess(const String& result);
    };
    virtual void evaluateJavaScriptFunction(ErrorString&, const String& in_browsingContextHandle, const String* opt_in_frameHandle, const String& in_function, const Inspector::InspectorArray& in_arguments, const bool* opt_in_expectsImplicitCallbackArgument, const int* opt_in_callbackTimeout, Ref<EvaluateJavaScriptFunctionCallback>&& callback) = 0;
    virtual void performMouseInteraction(ErrorString&, const String& in_handle, const Inspector::InspectorObject& in_position, const String& in_button, const String& in_interaction, const Inspector::InspectorArray& in_modifiers, RefPtr<Inspector::Protocol::Automation::Point>& out_position) = 0;
    virtual void performKeyboardInteractions(ErrorString&, const String& in_handle, const Inspector::InspectorArray& in_interactions) = 0;
    class TakeScreenshotCallback : public BackendDispatcher::CallbackBase {
    public:
        TakeScreenshotCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess(const String& data);
    };
    virtual void takeScreenshot(ErrorString&, const String& in_handle, Ref<TakeScreenshotCallback>&& callback) = 0;
    class ResolveChildFrameHandleCallback : public BackendDispatcher::CallbackBase {
    public:
        ResolveChildFrameHandleCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess(const String& result);
    };
    virtual void resolveChildFrameHandle(ErrorString&, const String& in_browsingContextHandle, const String* opt_in_frameHandle, const int* opt_in_ordinal, const String* opt_in_name, const String* opt_in_nodeHandle, Ref<ResolveChildFrameHandleCallback>&& callback) = 0;
    class ResolveParentFrameHandleCallback : public BackendDispatcher::CallbackBase {
    public:
        ResolveParentFrameHandleCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess(const String& result);
    };
    virtual void resolveParentFrameHandle(ErrorString&, const String& in_browsingContextHandle, const String& in_frameHandle, Ref<ResolveParentFrameHandleCallback>&& callback) = 0;
    class ComputeElementLayoutCallback : public BackendDispatcher::CallbackBase {
    public:
        ComputeElementLayoutCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess(RefPtr<Inspector::Protocol::Automation::Rect>&& rect);
    };
    virtual void computeElementLayout(ErrorString&, const String& in_browsingContextHandle, const String& in_frameHandle, const String& in_nodeHandle, const bool* opt_in_scrollIntoViewIfNeeded, const bool* opt_in_useViewportCoordinates, Ref<ComputeElementLayoutCallback>&& callback) = 0;
    virtual void isShowingJavaScriptDialog(ErrorString&, const String& in_browsingContextHandle, bool* out_result) = 0;
    virtual void dismissCurrentJavaScriptDialog(ErrorString&, const String& in_browsingContextHandle) = 0;
    virtual void acceptCurrentJavaScriptDialog(ErrorString&, const String& in_browsingContextHandle) = 0;
    virtual void messageOfCurrentJavaScriptDialog(ErrorString&, const String& in_browsingContextHandle, String* out_message) = 0;
    virtual void setUserInputForCurrentJavaScriptPrompt(ErrorString&, const String& in_browsingContextHandle, const String& in_userInput) = 0;
    class GetAllCookiesCallback : public BackendDispatcher::CallbackBase {
    public:
        GetAllCookiesCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Automation::Cookie>>&& cookies);
    };
    virtual void getAllCookies(ErrorString&, const String& in_browsingContextHandle, Ref<GetAllCookiesCallback>&& callback) = 0;
    class DeleteSingleCookieCallback : public BackendDispatcher::CallbackBase {
    public:
        DeleteSingleCookieCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess();
    };
    virtual void deleteSingleCookie(ErrorString&, const String& in_browsingContextHandle, const String& in_cookieName, Ref<DeleteSingleCookieCallback>&& callback) = 0;
    class AddSingleCookieCallback : public BackendDispatcher::CallbackBase {
    public:
        AddSingleCookieCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess();
    };
    virtual void addSingleCookie(ErrorString&, const String& in_browsingContextHandle, const Inspector::InspectorObject& in_cookie, Ref<AddSingleCookieCallback>&& callback) = 0;
    class DeleteAllCookiesCallback : public BackendDispatcher::CallbackBase {
    public:
        DeleteAllCookiesCallback(Ref<BackendDispatcher>&&, int id);
        void sendSuccess();
    };
    virtual void deleteAllCookies(ErrorString&, const String& in_browsingContextHandle, Ref<DeleteAllCookiesCallback>&& callback) = 0;
protected:
    virtual ~AutomationBackendDispatcherHandler();
};

class AutomationBackendDispatcher final : public SupplementalBackendDispatcher {
public:
    static Ref<AutomationBackendDispatcher> create(BackendDispatcher&, AutomationBackendDispatcherHandler*);
    void dispatch(long requestId, const String& method, Ref<InspectorObject>&& message) override;
private:
    void getBrowsingContexts(long requestId, RefPtr<InspectorObject>&& parameters);
    void getBrowsingContext(long requestId, RefPtr<InspectorObject>&& parameters);
    void createBrowsingContext(long requestId, RefPtr<InspectorObject>&& parameters);
    void closeBrowsingContext(long requestId, RefPtr<InspectorObject>&& parameters);
    void switchToBrowsingContext(long requestId, RefPtr<InspectorObject>&& parameters);
    void resizeWindowOfBrowsingContext(long requestId, RefPtr<InspectorObject>&& parameters);
    void moveWindowOfBrowsingContext(long requestId, RefPtr<InspectorObject>&& parameters);
    void navigateBrowsingContext(long requestId, RefPtr<InspectorObject>&& parameters);
    void goBackInBrowsingContext(long requestId, RefPtr<InspectorObject>&& parameters);
    void goForwardInBrowsingContext(long requestId, RefPtr<InspectorObject>&& parameters);
    void reloadBrowsingContext(long requestId, RefPtr<InspectorObject>&& parameters);
    void inspectBrowsingContext(long requestId, RefPtr<InspectorObject>&& parameters);
    void evaluateJavaScriptFunction(long requestId, RefPtr<InspectorObject>&& parameters);
    void performMouseInteraction(long requestId, RefPtr<InspectorObject>&& parameters);
    void performKeyboardInteractions(long requestId, RefPtr<InspectorObject>&& parameters);
    void takeScreenshot(long requestId, RefPtr<InspectorObject>&& parameters);
    void resolveChildFrameHandle(long requestId, RefPtr<InspectorObject>&& parameters);
    void resolveParentFrameHandle(long requestId, RefPtr<InspectorObject>&& parameters);
    void computeElementLayout(long requestId, RefPtr<InspectorObject>&& parameters);
    void isShowingJavaScriptDialog(long requestId, RefPtr<InspectorObject>&& parameters);
    void dismissCurrentJavaScriptDialog(long requestId, RefPtr<InspectorObject>&& parameters);
    void acceptCurrentJavaScriptDialog(long requestId, RefPtr<InspectorObject>&& parameters);
    void messageOfCurrentJavaScriptDialog(long requestId, RefPtr<InspectorObject>&& parameters);
    void setUserInputForCurrentJavaScriptPrompt(long requestId, RefPtr<InspectorObject>&& parameters);
    void getAllCookies(long requestId, RefPtr<InspectorObject>&& parameters);
    void deleteSingleCookie(long requestId, RefPtr<InspectorObject>&& parameters);
    void addSingleCookie(long requestId, RefPtr<InspectorObject>&& parameters);
    void deleteAllCookies(long requestId, RefPtr<InspectorObject>&& parameters);
private:
    AutomationBackendDispatcher(BackendDispatcher&, AutomationBackendDispatcherHandler*);
    AutomationBackendDispatcherHandler* m_agent { nullptr };
};

} // namespace Inspector
