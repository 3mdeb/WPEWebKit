/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(WEBGL2)

#include "JSWebGL2RenderingContext.h"

#include "ExceptionCode.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructor.h"
#include "JSDOMConvert.h"
#include "JSHTMLCanvasElement.h"
#include "JSHTMLImageElement.h"
#include "JSHTMLVideoElement.h"
#include "JSImageData.h"
#include "JSWebGLActiveInfo.h"
#include "JSWebGLBuffer.h"
#include "JSWebGLProgram.h"
#include "JSWebGLQuery.h"
#include "JSWebGLSampler.h"
#include "JSWebGLSync.h"
#include "JSWebGLTransformFeedback.h"
#include "JSWebGLUniformLocation.h"
#include "JSWebGLVertexArrayObject.h"
#include "WebGLActiveInfo.h"
#include "WebGLQuery.h"
#include "WebGLSampler.h"
#include "WebGLSync.h"
#include "WebGLTransformFeedback.h"
#include "WebGLVertexArrayObject.h"
#include <runtime/Error.h>
#include <runtime/FunctionPrototype.h>
#include <wtf/GetPtr.h>

using namespace JSC;

namespace WebCore {

// Functions

JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCopyBufferSubData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetBufferSubData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBlitFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionFramebufferTextureLayer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetInternalformatParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionInvalidateFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionInvalidateSubFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionReadBuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionRenderbufferStorageMultisample(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexStorage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexStorage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexImage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCopyTexSubImage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCompressedTexImage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCompressedTexSubImage3D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetFragDataLocation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform1ui(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform2ui(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform3ui(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform4ui(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform1uiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform2uiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform3uiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform4uiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x3fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x2fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x4fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x2fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x4fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x3fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4i(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4iv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4ui(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribIPointer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribDivisor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawArraysInstanced(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawElementsInstanced(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawRangeElements(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawBuffers(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferuiv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferfv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferfi(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBeginQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionEndQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetQuery(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetQueryParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateSampler(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteSampler(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsSampler(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindSampler(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionSamplerParameteri(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionSamplerParameterf(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetSamplerParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionFenceSync(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsSync(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteSync(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClientWaitSync(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionWaitSync(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetSyncParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBeginTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionEndTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTransformFeedbackVaryings(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetTransformFeedbackVarying(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionPauseTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionResumeTransformFeedback(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindBufferBase(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindBufferRange(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetIndexedParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetUniformIndices(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniforms(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetUniformBlockIndex(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockName(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformBlockBinding(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateVertexArray(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteVertexArray(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsVertexArray(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindVertexArray(JSC::ExecState*);

// Attributes

JSC::EncodedJSValue jsWebGL2RenderingContextConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSWebGL2RenderingContextConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);

class JSWebGL2RenderingContextPrototype : public JSC::JSNonFinalObject {
public:
    typedef JSC::JSNonFinalObject Base;
    static JSWebGL2RenderingContextPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSWebGL2RenderingContextPrototype* ptr = new (NotNull, JSC::allocateCell<JSWebGL2RenderingContextPrototype>(vm.heap)) JSWebGL2RenderingContextPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSWebGL2RenderingContextPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};

typedef JSDOMConstructorNotConstructable<JSWebGL2RenderingContext> JSWebGL2RenderingContextConstructor;

/* Hash table for constructor */

static const HashTableValue JSWebGL2RenderingContextConstructorTableValues[] =
{
    { "READ_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C02) } },
    { "UNPACK_ROW_LENGTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF2) } },
    { "UNPACK_SKIP_ROWS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF3) } },
    { "UNPACK_SKIP_PIXELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF4) } },
    { "PACK_ROW_LENGTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D02) } },
    { "PACK_SKIP_ROWS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D03) } },
    { "PACK_SKIP_PIXELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D04) } },
    { "COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1800) } },
    { "DEPTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1801) } },
    { "STENCIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1802) } },
    { "RED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1903) } },
    { "RGB8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8051) } },
    { "RGBA8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8058) } },
    { "RGB10_A2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8059) } },
    { "TEXTURE_BINDING_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806A) } },
    { "UNPACK_SKIP_IMAGES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806D) } },
    { "UNPACK_IMAGE_HEIGHT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806E) } },
    { "TEXTURE_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806F) } },
    { "TEXTURE_WRAP_R", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8072) } },
    { "MAX_3D_TEXTURE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8073) } },
    { "UNSIGNED_INT_2_10_10_10_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8368) } },
    { "MAX_ELEMENTS_VERTICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80E8) } },
    { "MAX_ELEMENTS_INDICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80E9) } },
    { "TEXTURE_MIN_LOD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813A) } },
    { "TEXTURE_MAX_LOD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813B) } },
    { "TEXTURE_BASE_LEVEL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813C) } },
    { "TEXTURE_MAX_LEVEL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813D) } },
    { "MIN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8007) } },
    { "MAX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8008) } },
    { "DEPTH_COMPONENT24", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x81A6) } },
    { "MAX_TEXTURE_LOD_BIAS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84FD) } },
    { "TEXTURE_COMPARE_MODE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884C) } },
    { "TEXTURE_COMPARE_FUNC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884D) } },
    { "CURRENT_QUERY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8865) } },
    { "QUERY_RESULT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8866) } },
    { "QUERY_RESULT_AVAILABLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8867) } },
    { "STREAM_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E1) } },
    { "STREAM_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E2) } },
    { "STATIC_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E5) } },
    { "STATIC_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E6) } },
    { "DYNAMIC_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E9) } },
    { "DYNAMIC_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EA) } },
    { "MAX_DRAW_BUFFERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8824) } },
    { "DRAW_BUFFER0", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8825) } },
    { "DRAW_BUFFER1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8826) } },
    { "DRAW_BUFFER2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8827) } },
    { "DRAW_BUFFER3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8828) } },
    { "DRAW_BUFFER4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8829) } },
    { "DRAW_BUFFER5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882A) } },
    { "DRAW_BUFFER6", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882B) } },
    { "DRAW_BUFFER7", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882C) } },
    { "DRAW_BUFFER8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882D) } },
    { "DRAW_BUFFER9", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882E) } },
    { "DRAW_BUFFER10", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882F) } },
    { "DRAW_BUFFER11", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8830) } },
    { "DRAW_BUFFER12", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8831) } },
    { "DRAW_BUFFER13", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8832) } },
    { "DRAW_BUFFER14", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8833) } },
    { "DRAW_BUFFER15", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8834) } },
    { "MAX_FRAGMENT_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B49) } },
    { "MAX_VERTEX_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4A) } },
    { "SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5F) } },
    { "SAMPLER_2D_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B62) } },
    { "FRAGMENT_SHADER_DERIVATIVE_HINT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B8B) } },
    { "PIXEL_PACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EB) } },
    { "PIXEL_UNPACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EC) } },
    { "PIXEL_PACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88ED) } },
    { "PIXEL_UNPACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EF) } },
    { "FLOAT_MAT2x3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B65) } },
    { "FLOAT_MAT2x4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B66) } },
    { "FLOAT_MAT3x2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B67) } },
    { "FLOAT_MAT3x4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B68) } },
    { "FLOAT_MAT4x2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B69) } },
    { "FLOAT_MAT4x3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B6A) } },
    { "SRGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C40) } },
    { "SRGB8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C41) } },
    { "SRGB8_ALPHA8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C43) } },
    { "COMPARE_REF_TO_TEXTURE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884E) } },
    { "RGBA32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8814) } },
    { "RGB32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8815) } },
    { "RGBA16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x881A) } },
    { "RGB16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x881B) } },
    { "VERTEX_ATTRIB_ARRAY_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FD) } },
    { "MAX_ARRAY_TEXTURE_LAYERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FF) } },
    { "MIN_PROGRAM_TEXEL_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8904) } },
    { "MAX_PROGRAM_TEXEL_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8905) } },
    { "MAX_VARYING_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4B) } },
    { "TEXTURE_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C1A) } },
    { "TEXTURE_BINDING_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C1D) } },
    { "R11F_G11F_B10F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3A) } },
    { "UNSIGNED_INT_10F_11F_11F_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3B) } },
    { "RGB9_E5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3D) } },
    { "UNSIGNED_INT_5_9_9_9_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3E) } },
    { "TRANSFORM_FEEDBACK_BUFFER_MODE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C7F) } },
    { "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C80) } },
    { "TRANSFORM_FEEDBACK_VARYINGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C83) } },
    { "TRANSFORM_FEEDBACK_BUFFER_START", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C84) } },
    { "TRANSFORM_FEEDBACK_BUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C85) } },
    { "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C88) } },
    { "RASTERIZER_DISCARD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C89) } },
    { "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8A) } },
    { "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8B) } },
    { "INTERLEAVED_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8C) } },
    { "SEPARATE_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8D) } },
    { "TRANSFORM_FEEDBACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8E) } },
    { "TRANSFORM_FEEDBACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8F) } },
    { "RGBA32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D70) } },
    { "RGB32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D71) } },
    { "RGBA16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D76) } },
    { "RGB16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D77) } },
    { "RGBA8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D7C) } },
    { "RGB8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D7D) } },
    { "RGBA32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D82) } },
    { "RGB32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D83) } },
    { "RGBA16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D88) } },
    { "RGB16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D89) } },
    { "RGBA8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D8E) } },
    { "RGB8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D8F) } },
    { "RED_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D94) } },
    { "RGB_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D98) } },
    { "RGBA_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D99) } },
    { "SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC1) } },
    { "SAMPLER_2D_ARRAY_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC4) } },
    { "SAMPLER_CUBE_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC5) } },
    { "UNSIGNED_INT_VEC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC6) } },
    { "UNSIGNED_INT_VEC3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC7) } },
    { "UNSIGNED_INT_VEC4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC8) } },
    { "INT_SAMPLER_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCA) } },
    { "INT_SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCB) } },
    { "INT_SAMPLER_CUBE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCC) } },
    { "INT_SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCF) } },
    { "UNSIGNED_INT_SAMPLER_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD2) } },
    { "UNSIGNED_INT_SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD3) } },
    { "UNSIGNED_INT_SAMPLER_CUBE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD4) } },
    { "UNSIGNED_INT_SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD7) } },
    { "DEPTH_COMPONENT32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAC) } },
    { "DEPTH32F_STENCIL8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAD) } },
    { "FLOAT_32_UNSIGNED_INT_24_8_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DAD) } },
    { "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8210) } },
    { "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8211) } },
    { "FRAMEBUFFER_ATTACHMENT_RED_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8212) } },
    { "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8213) } },
    { "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8214) } },
    { "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8215) } },
    { "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8216) } },
    { "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8217) } },
    { "FRAMEBUFFER_DEFAULT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8218) } },
    { "DEPTH_STENCIL_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x821A) } },
    { "DEPTH_STENCIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84F9) } },
    { "UNSIGNED_INT_24_8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84FA) } },
    { "DEPTH24_STENCIL8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88F0) } },
    { "UNSIGNED_NORMALIZED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C17) } },
    { "DRAW_FRAMEBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA6) } },
    { "READ_FRAMEBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA8) } },
    { "DRAW_FRAMEBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA9) } },
    { "READ_FRAMEBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAA) } },
    { "RENDERBUFFER_SAMPLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAB) } },
    { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD4) } },
    { "MAX_COLOR_ATTACHMENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CDF) } },
    { "COLOR_ATTACHMENT1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE1) } },
    { "COLOR_ATTACHMENT2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE2) } },
    { "COLOR_ATTACHMENT3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE3) } },
    { "COLOR_ATTACHMENT4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE4) } },
    { "COLOR_ATTACHMENT5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE5) } },
    { "COLOR_ATTACHMENT6", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE6) } },
    { "COLOR_ATTACHMENT7", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE7) } },
    { "COLOR_ATTACHMENT8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE8) } },
    { "COLOR_ATTACHMENT9", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE9) } },
    { "COLOR_ATTACHMENT10", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEA) } },
    { "COLOR_ATTACHMENT11", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEB) } },
    { "COLOR_ATTACHMENT12", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEC) } },
    { "COLOR_ATTACHMENT13", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CED) } },
    { "COLOR_ATTACHMENT14", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEE) } },
    { "COLOR_ATTACHMENT15", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEF) } },
    { "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D56) } },
    { "MAX_SAMPLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D57) } },
    { "HALF_FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x140B) } },
    { "RG", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8227) } },
    { "RG_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8228) } },
    { "R8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8229) } },
    { "RG8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822B) } },
    { "R16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822D) } },
    { "R32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822E) } },
    { "RG16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822F) } },
    { "RG32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8230) } },
    { "R8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8231) } },
    { "R8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8232) } },
    { "R16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8233) } },
    { "R16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8234) } },
    { "R32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8235) } },
    { "R32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8236) } },
    { "RG8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8237) } },
    { "RG8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8238) } },
    { "RG16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8239) } },
    { "RG16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823A) } },
    { "RG32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823B) } },
    { "RG32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823C) } },
    { "VERTEX_ARRAY_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x85B5) } },
    { "R8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F94) } },
    { "RG8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F95) } },
    { "RGB8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F96) } },
    { "RGBA8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F97) } },
    { "SIGNED_NORMALIZED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F9C) } },
    { "PRIMITIVE_RESTART_FIXED_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D69) } },
    { "COPY_READ_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F36) } },
    { "COPY_WRITE_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F37) } },
    { "COPY_READ_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F36) } },
    { "COPY_WRITE_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F37) } },
    { "UNIFORM_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A11) } },
    { "UNIFORM_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A28) } },
    { "UNIFORM_BUFFER_START", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A29) } },
    { "UNIFORM_BUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2A) } },
    { "MAX_VERTEX_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2B) } },
    { "MAX_FRAGMENT_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2D) } },
    { "MAX_COMBINED_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2E) } },
    { "MAX_UNIFORM_BUFFER_BINDINGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2F) } },
    { "MAX_UNIFORM_BLOCK_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A30) } },
    { "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A31) } },
    { "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A33) } },
    { "UNIFORM_BUFFER_OFFSET_ALIGNMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A34) } },
    { "ACTIVE_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A36) } },
    { "UNIFORM_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A37) } },
    { "UNIFORM_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A38) } },
    { "UNIFORM_BLOCK_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3A) } },
    { "UNIFORM_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3B) } },
    { "UNIFORM_ARRAY_STRIDE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3C) } },
    { "UNIFORM_MATRIX_STRIDE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3D) } },
    { "UNIFORM_IS_ROW_MAJOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3E) } },
    { "UNIFORM_BLOCK_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3F) } },
    { "UNIFORM_BLOCK_DATA_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A40) } },
    { "UNIFORM_BLOCK_ACTIVE_UNIFORMS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A42) } },
    { "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A43) } },
    { "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A44) } },
    { "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A46) } },
    { "INVALID_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0xFFFFFFFF) } },
    { "MAX_VERTEX_OUTPUT_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9122) } },
    { "MAX_FRAGMENT_INPUT_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9125) } },
    { "MAX_SERVER_WAIT_TIMEOUT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9111) } },
    { "OBJECT_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9112) } },
    { "SYNC_CONDITION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9113) } },
    { "SYNC_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9114) } },
    { "SYNC_FLAGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9115) } },
    { "SYNC_FENCE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9116) } },
    { "SYNC_GPU_COMMANDS_COMPLETE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9117) } },
    { "UNSIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9118) } },
    { "SIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9119) } },
    { "ALREADY_SIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911A) } },
    { "TIMEOUT_EXPIRED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911B) } },
    { "CONDITION_SATISFIED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911C) } },
    { "WAIT_FAILED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911D) } },
    { "SYNC_FLUSH_COMMANDS_BIT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x00000001) } },
    { "VERTEX_ATTRIB_ARRAY_DIVISOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FE) } },
    { "ANY_SAMPLES_PASSED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C2F) } },
    { "ANY_SAMPLES_PASSED_CONSERVATIVE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D6A) } },
    { "SAMPLER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8919) } },
    { "RGB10_A2UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x906F) } },
    { "TEXTURE_SWIZZLE_R", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E42) } },
    { "TEXTURE_SWIZZLE_G", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E43) } },
    { "TEXTURE_SWIZZLE_B", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E44) } },
    { "TEXTURE_SWIZZLE_A", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E45) } },
    { "GREEN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1904) } },
    { "BLUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1905) } },
    { "INT_2_10_10_10_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D9F) } },
    { "TRANSFORM_FEEDBACK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E22) } },
    { "TRANSFORM_FEEDBACK_PAUSED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E23) } },
    { "TRANSFORM_FEEDBACK_ACTIVE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E24) } },
    { "TRANSFORM_FEEDBACK_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E25) } },
    { "COMPRESSED_R11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9270) } },
    { "COMPRESSED_SIGNED_R11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9271) } },
    { "COMPRESSED_RG11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9272) } },
    { "COMPRESSED_SIGNED_RG11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9273) } },
    { "COMPRESSED_RGB8_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9274) } },
    { "COMPRESSED_SRGB8_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9275) } },
    { "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9276) } },
    { "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9277) } },
    { "COMPRESSED_RGBA8_ETC2_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9278) } },
    { "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9279) } },
    { "TEXTURE_IMMUTABLE_FORMAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x912F) } },
    { "MAX_ELEMENT_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D6B) } },
    { "NUM_SAMPLE_COUNTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9380) } },
    { "TEXTURE_IMMUTABLE_LEVELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x82DF) } },
    { "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FE) } },
    { "TIMEOUT_IGNORED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0xFFFFFFFFFFFFFFFF) } },
};

template<> JSValue JSWebGL2RenderingContextConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    UNUSED_PARAM(vm);
    return globalObject.functionPrototype();
}

template<> void JSWebGL2RenderingContextConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->prototype, JSWebGL2RenderingContext::prototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("WebGL2RenderingContext"))), ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
    reifyStaticProperties(vm, JSWebGL2RenderingContextConstructorTableValues, *this);
}

template<> const ClassInfo JSWebGL2RenderingContextConstructor::s_info = { "WebGL2RenderingContext", &Base::s_info, 0, CREATE_METHOD_TABLE(JSWebGL2RenderingContextConstructor) };

/* Hash table for prototype */

static const HashTableValue JSWebGL2RenderingContextPrototypeTableValues[] =
{
    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsWebGL2RenderingContextConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSWebGL2RenderingContextConstructor) } },
    { "copyBufferSubData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCopyBufferSubData), (intptr_t) (5) } },
    { "getBufferSubData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetBufferSubData), (intptr_t) (3) } },
    { "blitFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBlitFramebuffer), (intptr_t) (10) } },
    { "framebufferTextureLayer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionFramebufferTextureLayer), (intptr_t) (5) } },
    { "getInternalformatParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetInternalformatParameter), (intptr_t) (3) } },
    { "invalidateFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionInvalidateFramebuffer), (intptr_t) (2) } },
    { "invalidateSubFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionInvalidateSubFramebuffer), (intptr_t) (6) } },
    { "readBuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionReadBuffer), (intptr_t) (1) } },
    { "renderbufferStorageMultisample", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionRenderbufferStorageMultisample), (intptr_t) (5) } },
    { "texStorage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionTexStorage2D), (intptr_t) (5) } },
    { "texStorage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionTexStorage3D), (intptr_t) (6) } },
    { "texImage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionTexImage3D), (intptr_t) (10) } },
    { "texSubImage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D), (intptr_t) (11) } },
    { "copyTexSubImage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCopyTexSubImage3D), (intptr_t) (9) } },
    { "compressedTexImage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCompressedTexImage3D), (intptr_t) (9) } },
    { "compressedTexSubImage3D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCompressedTexSubImage3D), (intptr_t) (11) } },
    { "getFragDataLocation", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetFragDataLocation), (intptr_t) (2) } },
    { "uniform1ui", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform1ui), (intptr_t) (2) } },
    { "uniform2ui", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform2ui), (intptr_t) (3) } },
    { "uniform3ui", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform3ui), (intptr_t) (4) } },
    { "uniform4ui", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform4ui), (intptr_t) (5) } },
    { "uniform1uiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform1uiv), (intptr_t) (2) } },
    { "uniform2uiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform2uiv), (intptr_t) (2) } },
    { "uniform3uiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform3uiv), (intptr_t) (2) } },
    { "uniform4uiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniform4uiv), (intptr_t) (2) } },
    { "uniformMatrix2x3fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x3fv), (intptr_t) (3) } },
    { "uniformMatrix3x2fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x2fv), (intptr_t) (3) } },
    { "uniformMatrix2x4fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x4fv), (intptr_t) (3) } },
    { "uniformMatrix4x2fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x2fv), (intptr_t) (3) } },
    { "uniformMatrix3x4fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x4fv), (intptr_t) (3) } },
    { "uniformMatrix4x3fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x3fv), (intptr_t) (3) } },
    { "vertexAttribI4i", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4i), (intptr_t) (5) } },
    { "vertexAttribI4iv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4iv), (intptr_t) (2) } },
    { "vertexAttribI4ui", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4ui), (intptr_t) (5) } },
    { "vertexAttribI4uiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uiv), (intptr_t) (2) } },
    { "vertexAttribIPointer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribIPointer), (intptr_t) (5) } },
    { "vertexAttribDivisor", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionVertexAttribDivisor), (intptr_t) (2) } },
    { "drawArraysInstanced", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDrawArraysInstanced), (intptr_t) (4) } },
    { "drawElementsInstanced", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDrawElementsInstanced), (intptr_t) (5) } },
    { "drawRangeElements", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDrawRangeElements), (intptr_t) (6) } },
    { "drawBuffers", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDrawBuffers), (intptr_t) (1) } },
    { "clearBufferiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionClearBufferiv), (intptr_t) (3) } },
    { "clearBufferuiv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionClearBufferuiv), (intptr_t) (3) } },
    { "clearBufferfv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionClearBufferfv), (intptr_t) (3) } },
    { "clearBufferfi", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionClearBufferfi), (intptr_t) (4) } },
    { "createQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCreateQuery), (intptr_t) (0) } },
    { "deleteQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDeleteQuery), (intptr_t) (1) } },
    { "isQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionIsQuery), (intptr_t) (1) } },
    { "beginQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBeginQuery), (intptr_t) (2) } },
    { "endQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionEndQuery), (intptr_t) (1) } },
    { "getQuery", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetQuery), (intptr_t) (2) } },
    { "getQueryParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetQueryParameter), (intptr_t) (2) } },
    { "createSampler", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCreateSampler), (intptr_t) (0) } },
    { "deleteSampler", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDeleteSampler), (intptr_t) (1) } },
    { "isSampler", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionIsSampler), (intptr_t) (1) } },
    { "bindSampler", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBindSampler), (intptr_t) (2) } },
    { "samplerParameteri", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionSamplerParameteri), (intptr_t) (3) } },
    { "samplerParameterf", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionSamplerParameterf), (intptr_t) (3) } },
    { "getSamplerParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetSamplerParameter), (intptr_t) (2) } },
    { "fenceSync", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionFenceSync), (intptr_t) (2) } },
    { "isSync", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionIsSync), (intptr_t) (1) } },
    { "deleteSync", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDeleteSync), (intptr_t) (1) } },
    { "clientWaitSync", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionClientWaitSync), (intptr_t) (3) } },
    { "waitSync", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionWaitSync), (intptr_t) (3) } },
    { "getSyncParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetSyncParameter), (intptr_t) (2) } },
    { "createTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCreateTransformFeedback), (intptr_t) (0) } },
    { "deleteTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDeleteTransformFeedback), (intptr_t) (1) } },
    { "isTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionIsTransformFeedback), (intptr_t) (1) } },
    { "bindTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBindTransformFeedback), (intptr_t) (2) } },
    { "beginTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBeginTransformFeedback), (intptr_t) (1) } },
    { "endTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionEndTransformFeedback), (intptr_t) (0) } },
    { "transformFeedbackVaryings", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionTransformFeedbackVaryings), (intptr_t) (3) } },
    { "getTransformFeedbackVarying", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetTransformFeedbackVarying), (intptr_t) (2) } },
    { "pauseTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionPauseTransformFeedback), (intptr_t) (0) } },
    { "resumeTransformFeedback", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionResumeTransformFeedback), (intptr_t) (0) } },
    { "bindBufferBase", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBindBufferBase), (intptr_t) (3) } },
    { "bindBufferRange", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBindBufferRange), (intptr_t) (5) } },
    { "getIndexedParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetIndexedParameter), (intptr_t) (2) } },
    { "getUniformIndices", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetUniformIndices), (intptr_t) (2) } },
    { "getActiveUniforms", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetActiveUniforms), (intptr_t) (3) } },
    { "getUniformBlockIndex", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetUniformBlockIndex), (intptr_t) (2) } },
    { "getActiveUniformBlockParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockParameter), (intptr_t) (3) } },
    { "getActiveUniformBlockName", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockName), (intptr_t) (2) } },
    { "uniformBlockBinding", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionUniformBlockBinding), (intptr_t) (3) } },
    { "createVertexArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionCreateVertexArray), (intptr_t) (0) } },
    { "deleteVertexArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionDeleteVertexArray), (intptr_t) (1) } },
    { "isVertexArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionIsVertexArray), (intptr_t) (1) } },
    { "bindVertexArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGL2RenderingContextPrototypeFunctionBindVertexArray), (intptr_t) (1) } },
    { "READ_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C02) } },
    { "UNPACK_ROW_LENGTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF2) } },
    { "UNPACK_SKIP_ROWS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF3) } },
    { "UNPACK_SKIP_PIXELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF4) } },
    { "PACK_ROW_LENGTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D02) } },
    { "PACK_SKIP_ROWS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D03) } },
    { "PACK_SKIP_PIXELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D04) } },
    { "COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1800) } },
    { "DEPTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1801) } },
    { "STENCIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1802) } },
    { "RED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1903) } },
    { "RGB8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8051) } },
    { "RGBA8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8058) } },
    { "RGB10_A2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8059) } },
    { "TEXTURE_BINDING_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806A) } },
    { "UNPACK_SKIP_IMAGES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806D) } },
    { "UNPACK_IMAGE_HEIGHT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806E) } },
    { "TEXTURE_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x806F) } },
    { "TEXTURE_WRAP_R", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8072) } },
    { "MAX_3D_TEXTURE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8073) } },
    { "UNSIGNED_INT_2_10_10_10_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8368) } },
    { "MAX_ELEMENTS_VERTICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80E8) } },
    { "MAX_ELEMENTS_INDICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80E9) } },
    { "TEXTURE_MIN_LOD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813A) } },
    { "TEXTURE_MAX_LOD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813B) } },
    { "TEXTURE_BASE_LEVEL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813C) } },
    { "TEXTURE_MAX_LEVEL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x813D) } },
    { "MIN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8007) } },
    { "MAX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8008) } },
    { "DEPTH_COMPONENT24", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x81A6) } },
    { "MAX_TEXTURE_LOD_BIAS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84FD) } },
    { "TEXTURE_COMPARE_MODE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884C) } },
    { "TEXTURE_COMPARE_FUNC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884D) } },
    { "CURRENT_QUERY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8865) } },
    { "QUERY_RESULT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8866) } },
    { "QUERY_RESULT_AVAILABLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8867) } },
    { "STREAM_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E1) } },
    { "STREAM_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E2) } },
    { "STATIC_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E5) } },
    { "STATIC_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E6) } },
    { "DYNAMIC_READ", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E9) } },
    { "DYNAMIC_COPY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EA) } },
    { "MAX_DRAW_BUFFERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8824) } },
    { "DRAW_BUFFER0", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8825) } },
    { "DRAW_BUFFER1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8826) } },
    { "DRAW_BUFFER2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8827) } },
    { "DRAW_BUFFER3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8828) } },
    { "DRAW_BUFFER4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8829) } },
    { "DRAW_BUFFER5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882A) } },
    { "DRAW_BUFFER6", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882B) } },
    { "DRAW_BUFFER7", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882C) } },
    { "DRAW_BUFFER8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882D) } },
    { "DRAW_BUFFER9", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882E) } },
    { "DRAW_BUFFER10", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x882F) } },
    { "DRAW_BUFFER11", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8830) } },
    { "DRAW_BUFFER12", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8831) } },
    { "DRAW_BUFFER13", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8832) } },
    { "DRAW_BUFFER14", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8833) } },
    { "DRAW_BUFFER15", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8834) } },
    { "MAX_FRAGMENT_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B49) } },
    { "MAX_VERTEX_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4A) } },
    { "SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5F) } },
    { "SAMPLER_2D_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B62) } },
    { "FRAGMENT_SHADER_DERIVATIVE_HINT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B8B) } },
    { "PIXEL_PACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EB) } },
    { "PIXEL_UNPACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EC) } },
    { "PIXEL_PACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88ED) } },
    { "PIXEL_UNPACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88EF) } },
    { "FLOAT_MAT2x3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B65) } },
    { "FLOAT_MAT2x4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B66) } },
    { "FLOAT_MAT3x2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B67) } },
    { "FLOAT_MAT3x4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B68) } },
    { "FLOAT_MAT4x2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B69) } },
    { "FLOAT_MAT4x3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B6A) } },
    { "SRGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C40) } },
    { "SRGB8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C41) } },
    { "SRGB8_ALPHA8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C43) } },
    { "COMPARE_REF_TO_TEXTURE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x884E) } },
    { "RGBA32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8814) } },
    { "RGB32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8815) } },
    { "RGBA16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x881A) } },
    { "RGB16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x881B) } },
    { "VERTEX_ATTRIB_ARRAY_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FD) } },
    { "MAX_ARRAY_TEXTURE_LAYERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FF) } },
    { "MIN_PROGRAM_TEXEL_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8904) } },
    { "MAX_PROGRAM_TEXEL_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8905) } },
    { "MAX_VARYING_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4B) } },
    { "TEXTURE_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C1A) } },
    { "TEXTURE_BINDING_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C1D) } },
    { "R11F_G11F_B10F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3A) } },
    { "UNSIGNED_INT_10F_11F_11F_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3B) } },
    { "RGB9_E5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3D) } },
    { "UNSIGNED_INT_5_9_9_9_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C3E) } },
    { "TRANSFORM_FEEDBACK_BUFFER_MODE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C7F) } },
    { "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C80) } },
    { "TRANSFORM_FEEDBACK_VARYINGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C83) } },
    { "TRANSFORM_FEEDBACK_BUFFER_START", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C84) } },
    { "TRANSFORM_FEEDBACK_BUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C85) } },
    { "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C88) } },
    { "RASTERIZER_DISCARD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C89) } },
    { "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8A) } },
    { "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8B) } },
    { "INTERLEAVED_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8C) } },
    { "SEPARATE_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8D) } },
    { "TRANSFORM_FEEDBACK_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8E) } },
    { "TRANSFORM_FEEDBACK_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C8F) } },
    { "RGBA32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D70) } },
    { "RGB32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D71) } },
    { "RGBA16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D76) } },
    { "RGB16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D77) } },
    { "RGBA8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D7C) } },
    { "RGB8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D7D) } },
    { "RGBA32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D82) } },
    { "RGB32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D83) } },
    { "RGBA16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D88) } },
    { "RGB16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D89) } },
    { "RGBA8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D8E) } },
    { "RGB8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D8F) } },
    { "RED_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D94) } },
    { "RGB_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D98) } },
    { "RGBA_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D99) } },
    { "SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC1) } },
    { "SAMPLER_2D_ARRAY_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC4) } },
    { "SAMPLER_CUBE_SHADOW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC5) } },
    { "UNSIGNED_INT_VEC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC6) } },
    { "UNSIGNED_INT_VEC3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC7) } },
    { "UNSIGNED_INT_VEC4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DC8) } },
    { "INT_SAMPLER_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCA) } },
    { "INT_SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCB) } },
    { "INT_SAMPLER_CUBE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCC) } },
    { "INT_SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DCF) } },
    { "UNSIGNED_INT_SAMPLER_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD2) } },
    { "UNSIGNED_INT_SAMPLER_3D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD3) } },
    { "UNSIGNED_INT_SAMPLER_CUBE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD4) } },
    { "UNSIGNED_INT_SAMPLER_2D_ARRAY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DD7) } },
    { "DEPTH_COMPONENT32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAC) } },
    { "DEPTH32F_STENCIL8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAD) } },
    { "FLOAT_32_UNSIGNED_INT_24_8_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DAD) } },
    { "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8210) } },
    { "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8211) } },
    { "FRAMEBUFFER_ATTACHMENT_RED_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8212) } },
    { "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8213) } },
    { "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8214) } },
    { "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8215) } },
    { "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8216) } },
    { "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8217) } },
    { "FRAMEBUFFER_DEFAULT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8218) } },
    { "DEPTH_STENCIL_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x821A) } },
    { "DEPTH_STENCIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84F9) } },
    { "UNSIGNED_INT_24_8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84FA) } },
    { "DEPTH24_STENCIL8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88F0) } },
    { "UNSIGNED_NORMALIZED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C17) } },
    { "DRAW_FRAMEBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA6) } },
    { "READ_FRAMEBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA8) } },
    { "DRAW_FRAMEBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA9) } },
    { "READ_FRAMEBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAA) } },
    { "RENDERBUFFER_SAMPLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CAB) } },
    { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD4) } },
    { "MAX_COLOR_ATTACHMENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CDF) } },
    { "COLOR_ATTACHMENT1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE1) } },
    { "COLOR_ATTACHMENT2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE2) } },
    { "COLOR_ATTACHMENT3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE3) } },
    { "COLOR_ATTACHMENT4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE4) } },
    { "COLOR_ATTACHMENT5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE5) } },
    { "COLOR_ATTACHMENT6", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE6) } },
    { "COLOR_ATTACHMENT7", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE7) } },
    { "COLOR_ATTACHMENT8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE8) } },
    { "COLOR_ATTACHMENT9", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE9) } },
    { "COLOR_ATTACHMENT10", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEA) } },
    { "COLOR_ATTACHMENT11", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEB) } },
    { "COLOR_ATTACHMENT12", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEC) } },
    { "COLOR_ATTACHMENT13", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CED) } },
    { "COLOR_ATTACHMENT14", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEE) } },
    { "COLOR_ATTACHMENT15", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CEF) } },
    { "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D56) } },
    { "MAX_SAMPLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D57) } },
    { "HALF_FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x140B) } },
    { "RG", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8227) } },
    { "RG_INTEGER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8228) } },
    { "R8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8229) } },
    { "RG8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822B) } },
    { "R16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822D) } },
    { "R32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822E) } },
    { "RG16F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x822F) } },
    { "RG32F", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8230) } },
    { "R8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8231) } },
    { "R8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8232) } },
    { "R16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8233) } },
    { "R16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8234) } },
    { "R32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8235) } },
    { "R32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8236) } },
    { "RG8I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8237) } },
    { "RG8UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8238) } },
    { "RG16I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8239) } },
    { "RG16UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823A) } },
    { "RG32I", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823B) } },
    { "RG32UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x823C) } },
    { "VERTEX_ARRAY_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x85B5) } },
    { "R8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F94) } },
    { "RG8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F95) } },
    { "RGB8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F96) } },
    { "RGBA8_SNORM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F97) } },
    { "SIGNED_NORMALIZED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F9C) } },
    { "PRIMITIVE_RESTART_FIXED_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D69) } },
    { "COPY_READ_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F36) } },
    { "COPY_WRITE_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F37) } },
    { "COPY_READ_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F36) } },
    { "COPY_WRITE_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8F37) } },
    { "UNIFORM_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A11) } },
    { "UNIFORM_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A28) } },
    { "UNIFORM_BUFFER_START", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A29) } },
    { "UNIFORM_BUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2A) } },
    { "MAX_VERTEX_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2B) } },
    { "MAX_FRAGMENT_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2D) } },
    { "MAX_COMBINED_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2E) } },
    { "MAX_UNIFORM_BUFFER_BINDINGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A2F) } },
    { "MAX_UNIFORM_BLOCK_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A30) } },
    { "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A31) } },
    { "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A33) } },
    { "UNIFORM_BUFFER_OFFSET_ALIGNMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A34) } },
    { "ACTIVE_UNIFORM_BLOCKS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A36) } },
    { "UNIFORM_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A37) } },
    { "UNIFORM_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A38) } },
    { "UNIFORM_BLOCK_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3A) } },
    { "UNIFORM_OFFSET", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3B) } },
    { "UNIFORM_ARRAY_STRIDE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3C) } },
    { "UNIFORM_MATRIX_STRIDE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3D) } },
    { "UNIFORM_IS_ROW_MAJOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3E) } },
    { "UNIFORM_BLOCK_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A3F) } },
    { "UNIFORM_BLOCK_DATA_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A40) } },
    { "UNIFORM_BLOCK_ACTIVE_UNIFORMS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A42) } },
    { "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A43) } },
    { "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A44) } },
    { "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8A46) } },
    { "INVALID_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0xFFFFFFFF) } },
    { "MAX_VERTEX_OUTPUT_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9122) } },
    { "MAX_FRAGMENT_INPUT_COMPONENTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9125) } },
    { "MAX_SERVER_WAIT_TIMEOUT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9111) } },
    { "OBJECT_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9112) } },
    { "SYNC_CONDITION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9113) } },
    { "SYNC_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9114) } },
    { "SYNC_FLAGS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9115) } },
    { "SYNC_FENCE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9116) } },
    { "SYNC_GPU_COMMANDS_COMPLETE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9117) } },
    { "UNSIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9118) } },
    { "SIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9119) } },
    { "ALREADY_SIGNALED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911A) } },
    { "TIMEOUT_EXPIRED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911B) } },
    { "CONDITION_SATISFIED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911C) } },
    { "WAIT_FAILED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x911D) } },
    { "SYNC_FLUSH_COMMANDS_BIT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x00000001) } },
    { "VERTEX_ATTRIB_ARRAY_DIVISOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FE) } },
    { "ANY_SAMPLES_PASSED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8C2F) } },
    { "ANY_SAMPLES_PASSED_CONSERVATIVE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D6A) } },
    { "SAMPLER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8919) } },
    { "RGB10_A2UI", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x906F) } },
    { "TEXTURE_SWIZZLE_R", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E42) } },
    { "TEXTURE_SWIZZLE_G", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E43) } },
    { "TEXTURE_SWIZZLE_B", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E44) } },
    { "TEXTURE_SWIZZLE_A", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E45) } },
    { "GREEN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1904) } },
    { "BLUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1905) } },
    { "INT_2_10_10_10_REV", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D9F) } },
    { "TRANSFORM_FEEDBACK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E22) } },
    { "TRANSFORM_FEEDBACK_PAUSED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E23) } },
    { "TRANSFORM_FEEDBACK_ACTIVE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E24) } },
    { "TRANSFORM_FEEDBACK_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8E25) } },
    { "COMPRESSED_R11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9270) } },
    { "COMPRESSED_SIGNED_R11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9271) } },
    { "COMPRESSED_RG11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9272) } },
    { "COMPRESSED_SIGNED_RG11_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9273) } },
    { "COMPRESSED_RGB8_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9274) } },
    { "COMPRESSED_SRGB8_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9275) } },
    { "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9276) } },
    { "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9277) } },
    { "COMPRESSED_RGBA8_ETC2_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9278) } },
    { "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9279) } },
    { "TEXTURE_IMMUTABLE_FORMAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x912F) } },
    { "MAX_ELEMENT_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D6B) } },
    { "NUM_SAMPLE_COUNTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9380) } },
    { "TEXTURE_IMMUTABLE_LEVELS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x82DF) } },
    { "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88FE) } },
    { "TIMEOUT_IGNORED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0xFFFFFFFFFFFFFFFF) } },
};

const ClassInfo JSWebGL2RenderingContextPrototype::s_info = { "WebGL2RenderingContextPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSWebGL2RenderingContextPrototype) };

void JSWebGL2RenderingContextPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSWebGL2RenderingContextPrototypeTableValues, *this);
}

const ClassInfo JSWebGL2RenderingContext::s_info = { "WebGL2RenderingContext", &Base::s_info, 0, CREATE_METHOD_TABLE(JSWebGL2RenderingContext) };

JSWebGL2RenderingContext::JSWebGL2RenderingContext(Structure* structure, JSDOMGlobalObject& globalObject, Ref<WebGL2RenderingContext>&& impl)
    : JSWebGLRenderingContextBase(structure, globalObject, WTFMove(impl))
{
}

JSObject* JSWebGL2RenderingContext::createPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return JSWebGL2RenderingContextPrototype::create(vm, globalObject, JSWebGL2RenderingContextPrototype::createStructure(vm, globalObject, JSWebGLRenderingContextBase::prototype(vm, globalObject)));
}

JSObject* JSWebGL2RenderingContext::prototype(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSWebGL2RenderingContext>(vm, globalObject);
}

EncodedJSValue jsWebGL2RenderingContextConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    JSWebGL2RenderingContextPrototype* domObject = jsDynamicCast<JSWebGL2RenderingContextPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject))
        return throwVMTypeError(state);
    return JSValue::encode(JSWebGL2RenderingContext::getConstructor(state->vm(), domObject->globalObject()));
}

bool setJSWebGL2RenderingContextConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    JSWebGL2RenderingContextPrototype* domObject = jsDynamicCast<JSWebGL2RenderingContextPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject)) {
        throwVMTypeError(state);
        return false;
    }
    // Shadowing a built-in constructor
    return domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
}

JSValue JSWebGL2RenderingContext::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSWebGL2RenderingContextConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCopyBufferSubData(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "copyBufferSubData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto readTarget = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto writeTarget = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto readOffset = convert<int64_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto writeOffset = convert<int64_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto size = convert<int64_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.copyBufferSubData(WTFMove(readTarget), WTFMove(writeTarget), WTFMove(readOffset), WTFMove(writeOffset), WTFMove(size));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetBufferSubData(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getBufferSubData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto offset = convert<int64_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto returnedData = toArrayBuffer(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.getBufferSubData(WTFMove(target), WTFMove(offset), WTFMove(returnedData));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBlitFramebuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "blitFramebuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 10))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto srcX0 = convert<int32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto srcY0 = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto srcX1 = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto srcY1 = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dstX0 = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dstY0 = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dstX1 = convert<int32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dstY1 = convert<int32_t>(*state, state->argument(7), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto mask = convert<uint32_t>(*state, state->argument(8), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto filter = convert<uint32_t>(*state, state->argument(9), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.blitFramebuffer(WTFMove(srcX0), WTFMove(srcY0), WTFMove(srcX1), WTFMove(srcY1), WTFMove(dstX0), WTFMove(dstY0), WTFMove(dstX1), WTFMove(dstY1), WTFMove(mask), WTFMove(filter));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionFramebufferTextureLayer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "framebufferTextureLayer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto attachment = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto texture = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto layer = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.framebufferTextureLayer(WTFMove(target), WTFMove(attachment), WTFMove(texture), WTFMove(level), WTFMove(layer));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetInternalformatParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getInternalformatParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    return JSValue::encode(castedThis->getInternalformatParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionInvalidateFramebuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "invalidateFramebuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto attachments = toNativeArray<uint32_t>(state, state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.invalidateFramebuffer(WTFMove(target), WTFMove(attachments));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionInvalidateSubFramebuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "invalidateSubFramebuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto attachments = toNativeArray<uint32_t>(state, state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.invalidateSubFramebuffer(WTFMove(target), WTFMove(attachments), WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionReadBuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "readBuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto src = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.readBuffer(WTFMove(src));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionRenderbufferStorageMultisample(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "renderbufferStorageMultisample");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto samples = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.renderbufferStorageMultisample(WTFMove(target), WTFMove(samples), WTFMove(internalformat), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexStorage2D(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "texStorage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto levels = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.texStorage2D(WTFMove(target), WTFMove(levels), WTFMove(internalformat), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexStorage3D(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "texStorage3D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto levels = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto depth = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.texStorage3D(WTFMove(target), WTFMove(levels), WTFMove(internalformat), WTFMove(width), WTFMove(height), WTFMove(depth));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexImage3D(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "texImage3D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 10))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto depth = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto border = convert<int32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(7), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(8), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto pixels = toArrayBufferView(state->argument(9));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.texImage3D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(width), WTFMove(height), WTFMove(depth), WTFMove(border), WTFMove(format), WTFMove(type), WTFMove(pixels));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "texSubImage3D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 11))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zoffset = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto depth = convert<int32_t>(*state, state->argument(7), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(8), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(9), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto pixels = toArrayBufferView(state->argument(10));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.texSubImage3D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(zoffset), WTFMove(width), WTFMove(height), WTFMove(depth), WTFMove(format), WTFMove(type), WTFMove(pixels));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "texSubImage3D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zoffset = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    ImageData* source = nullptr;
    if (!state->argument(7).isUndefinedOrNull()) {
        source = JSImageData::toWrapped(state->uncheckedArgument(7));
        if (UNLIKELY(!source))
            return throwArgumentTypeError(*state, 7, "source", "WebGL2RenderingContext", "texSubImage3D", "ImageData");
    }
    impl.texSubImage3D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(zoffset), WTFMove(format), WTFMove(type), source);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D3(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "texSubImage3D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zoffset = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    HTMLImageElement* source = nullptr;
    if (!state->argument(7).isUndefinedOrNull()) {
        source = JSHTMLImageElement::toWrapped(state->uncheckedArgument(7));
        if (UNLIKELY(!source))
            return throwArgumentTypeError(*state, 7, "source", "WebGL2RenderingContext", "texSubImage3D", "HTMLImageElement");
    }
    impl.texSubImage3D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(zoffset), WTFMove(format), WTFMove(type), source);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D4(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "texSubImage3D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zoffset = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    HTMLCanvasElement* source = nullptr;
    if (!state->argument(7).isUndefinedOrNull()) {
        source = JSHTMLCanvasElement::toWrapped(state->uncheckedArgument(7));
        if (UNLIKELY(!source))
            return throwArgumentTypeError(*state, 7, "source", "WebGL2RenderingContext", "texSubImage3D", "HTMLCanvasElement");
    }
    impl.texSubImage3D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(zoffset), WTFMove(format), WTFMove(type), source);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D5(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "texSubImage3D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zoffset = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    HTMLVideoElement* source = nullptr;
    if (!state->argument(7).isUndefinedOrNull()) {
        source = JSHTMLVideoElement::toWrapped(state->uncheckedArgument(7));
        if (UNLIKELY(!source))
            return throwArgumentTypeError(*state, 7, "source", "WebGL2RenderingContext", "texSubImage3D", "HTMLVideoElement");
    }
    impl.texSubImage3D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(zoffset), WTFMove(format), WTFMove(type), source);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D(ExecState* state)
{
    size_t argsCount = std::min<size_t>(11, state->argumentCount());
    JSValue arg10(state->argument(10));
    if ((argsCount == 11 && (arg10.isUndefinedOrNull() || (arg10.isObject() && asObject(arg10)->inherits(JSArrayBufferView::info())))))
        return jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D1(state);
    JSValue arg7(state->argument(7));
    if ((argsCount == 8 && (arg7.isUndefinedOrNull() || (arg7.isObject() && asObject(arg7)->inherits(JSImageData::info())))))
        return jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D2(state);
    if ((argsCount == 8 && (arg7.isUndefinedOrNull() || (arg7.isObject() && asObject(arg7)->inherits(JSHTMLImageElement::info())))))
        return jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D3(state);
    if ((argsCount == 8 && (arg7.isUndefinedOrNull() || (arg7.isObject() && asObject(arg7)->inherits(JSHTMLCanvasElement::info())))))
        return jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D4(state);
    if ((argsCount == 8 && (arg7.isUndefinedOrNull() || (arg7.isObject() && asObject(arg7)->inherits(JSHTMLVideoElement::info())))))
        return jsWebGL2RenderingContextPrototypeFunctionTexSubImage3D5(state);
    if (UNLIKELY(argsCount < 8))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    return throwVMTypeError(state);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCopyTexSubImage3D(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "copyTexSubImage3D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 9))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zoffset = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<int32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(7), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(8), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.copyTexSubImage3D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(zoffset), WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCompressedTexImage3D(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "compressedTexImage3D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 9))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto depth = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto border = convert<int32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto imageSize = convert<int32_t>(*state, state->argument(7), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto data = toArrayBufferView(state->argument(8));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.compressedTexImage3D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(width), WTFMove(height), WTFMove(depth), WTFMove(border), WTFMove(imageSize), WTFMove(data));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCompressedTexSubImage3D(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "compressedTexSubImage3D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 11))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zoffset = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto depth = convert<int32_t>(*state, state->argument(7), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(8), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto imageSize = convert<int32_t>(*state, state->argument(9), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto data = toArrayBufferView(state->argument(10));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.compressedTexSubImage3D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(zoffset), WTFMove(width), WTFMove(height), WTFMove(depth), WTFMove(format), WTFMove(imageSize), WTFMove(data));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetFragDataLocation(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getFragDataLocation");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGL2RenderingContext", "getFragDataLocation", "WebGLProgram");
    }
    auto name = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsNumber(impl.getFragDataLocation(program, WTFMove(name)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform1ui(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniform1ui");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniform1ui", "WebGLUniformLocation");
    }
    auto v0 = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform1ui(location, WTFMove(v0));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform2ui(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniform2ui");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniform2ui", "WebGLUniformLocation");
    }
    auto v0 = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto v1 = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform2ui(location, WTFMove(v0), WTFMove(v1));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform3ui(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniform3ui");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniform3ui", "WebGLUniformLocation");
    }
    auto v0 = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto v1 = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto v2 = convert<uint32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform3ui(location, WTFMove(v0), WTFMove(v1), WTFMove(v2));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform4ui(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniform4ui");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniform4ui", "WebGLUniformLocation");
    }
    auto v0 = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto v1 = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto v2 = convert<uint32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto v3 = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform4ui(location, WTFMove(v0), WTFMove(v1), WTFMove(v2), WTFMove(v3));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform1uiv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniform1uiv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniform1uiv", "WebGLUniformLocation");
    }
    auto value = toUint32Array(state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform1uiv(location, WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform2uiv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniform2uiv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniform2uiv", "WebGLUniformLocation");
    }
    auto value = toUint32Array(state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform2uiv(location, WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform3uiv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniform3uiv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniform3uiv", "WebGLUniformLocation");
    }
    auto value = toUint32Array(state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform3uiv(location, WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniform4uiv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniform4uiv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniform4uiv", "WebGLUniformLocation");
    }
    auto value = toUint32Array(state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform4uiv(location, WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x3fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniformMatrix2x3fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniformMatrix2x3fv", "WebGLUniformLocation");
    }
    auto transpose = state->argument(1).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto value = toFloat32Array(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniformMatrix2x3fv(location, WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x2fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniformMatrix3x2fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniformMatrix3x2fv", "WebGLUniformLocation");
    }
    auto transpose = state->argument(1).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto value = toFloat32Array(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniformMatrix3x2fv(location, WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix2x4fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniformMatrix2x4fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniformMatrix2x4fv", "WebGLUniformLocation");
    }
    auto transpose = state->argument(1).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto value = toFloat32Array(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniformMatrix2x4fv(location, WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x2fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniformMatrix4x2fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniformMatrix4x2fv", "WebGLUniformLocation");
    }
    auto transpose = state->argument(1).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto value = toFloat32Array(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniformMatrix4x2fv(location, WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix3x4fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniformMatrix3x4fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniformMatrix3x4fv", "WebGLUniformLocation");
    }
    auto transpose = state->argument(1).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto value = toFloat32Array(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniformMatrix3x4fv(location, WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformMatrix4x3fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniformMatrix4x3fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGL2RenderingContext", "uniformMatrix4x3fv", "WebGLUniformLocation");
    }
    auto transpose = state->argument(1).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto value = toFloat32Array(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniformMatrix4x3fv(location, WTFMove(transpose), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4i(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "vertexAttribI4i");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto index = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto z = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto w = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.vertexAttribI4i(WTFMove(index), WTFMove(x), WTFMove(y), WTFMove(z), WTFMove(w));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4iv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "vertexAttribI4iv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto index = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto v = toInt32Array(state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.vertexAttribI4iv(WTFMove(index), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4ui(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "vertexAttribI4ui");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto index = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto z = convert<uint32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto w = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.vertexAttribI4ui(WTFMove(index), WTFMove(x), WTFMove(y), WTFMove(z), WTFMove(w));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribI4uiv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "vertexAttribI4uiv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto index = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto v = toUint32Array(state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.vertexAttribI4uiv(WTFMove(index), WTFMove(v));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribIPointer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "vertexAttribIPointer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto index = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto size = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto stride = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto offset = convert<int64_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.vertexAttribIPointer(WTFMove(index), WTFMove(size), WTFMove(type), WTFMove(stride), WTFMove(offset));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionVertexAttribDivisor(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "vertexAttribDivisor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto index = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto divisor = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.vertexAttribDivisor(WTFMove(index), WTFMove(divisor));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawArraysInstanced(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "drawArraysInstanced");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto mode = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto first = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto count = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto instanceCount = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawArraysInstanced(WTFMove(mode), WTFMove(first), WTFMove(count), WTFMove(instanceCount));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawElementsInstanced(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "drawElementsInstanced");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto mode = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto count = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto offset = convert<int64_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto instanceCount = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawElementsInstanced(WTFMove(mode), WTFMove(count), WTFMove(type), WTFMove(offset), WTFMove(instanceCount));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawRangeElements(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "drawRangeElements");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto mode = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto start = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto end = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto count = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto offset = convert<int64_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawRangeElements(WTFMove(mode), WTFMove(start), WTFMove(end), WTFMove(count), WTFMove(type), WTFMove(offset));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDrawBuffers(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "drawBuffers");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto buffers = toNativeArray<uint32_t>(state, state->argument(0));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawBuffers(WTFMove(buffers));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferiv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "clearBufferiv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto buffer = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto drawbuffer = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto value = toInt32Array(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.clearBufferiv(WTFMove(buffer), WTFMove(drawbuffer), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferuiv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "clearBufferuiv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto buffer = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto drawbuffer = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto value = toUint32Array(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.clearBufferuiv(WTFMove(buffer), WTFMove(drawbuffer), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferfv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "clearBufferfv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto buffer = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto drawbuffer = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto value = toFloat32Array(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.clearBufferfv(WTFMove(buffer), WTFMove(drawbuffer), WTFMove(value));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClearBufferfi(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "clearBufferfi");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto buffer = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto drawbuffer = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto depth = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto stencil = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.clearBufferfi(WTFMove(buffer), WTFMove(drawbuffer), WTFMove(depth), WTFMove(stencil));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateQuery(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "createQuery");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.createQuery());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteQuery(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "deleteQuery");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLQuery* query = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        query = JSWebGLQuery::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!query))
            return throwArgumentTypeError(*state, 0, "query", "WebGL2RenderingContext", "deleteQuery", "WebGLQuery");
    }
    impl.deleteQuery(query);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsQuery(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "isQuery");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLQuery* query = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        query = JSWebGLQuery::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!query))
            return throwArgumentTypeError(*state, 0, "query", "WebGL2RenderingContext", "isQuery", "WebGLQuery");
    }
    JSValue result = jsBoolean(impl.isQuery(query));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBeginQuery(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "beginQuery");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    WebGLQuery* query = nullptr;
    if (!state->argument(1).isUndefinedOrNull()) {
        query = JSWebGLQuery::toWrapped(state->uncheckedArgument(1));
        if (UNLIKELY(!query))
            return throwArgumentTypeError(*state, 1, "query", "WebGL2RenderingContext", "beginQuery", "WebGLQuery");
    }
    impl.beginQuery(WTFMove(target), query);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionEndQuery(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "endQuery");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.endQuery(WTFMove(target));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetQuery(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getQuery");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto pname = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getQuery(WTFMove(target), WTFMove(pname)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetQueryParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getQueryParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    return JSValue::encode(castedThis->getQueryParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateSampler(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "createSampler");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.createSampler());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteSampler(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "deleteSampler");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLSampler* sampler = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        sampler = JSWebGLSampler::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!sampler))
            return throwArgumentTypeError(*state, 0, "sampler", "WebGL2RenderingContext", "deleteSampler", "WebGLSampler");
    }
    impl.deleteSampler(sampler);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsSampler(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "isSampler");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLSampler* sampler = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        sampler = JSWebGLSampler::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!sampler))
            return throwArgumentTypeError(*state, 0, "sampler", "WebGL2RenderingContext", "isSampler", "WebGLSampler");
    }
    JSValue result = jsBoolean(impl.isSampler(sampler));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindSampler(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "bindSampler");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto unit = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    WebGLSampler* sampler = nullptr;
    if (!state->argument(1).isUndefinedOrNull()) {
        sampler = JSWebGLSampler::toWrapped(state->uncheckedArgument(1));
        if (UNLIKELY(!sampler))
            return throwArgumentTypeError(*state, 1, "sampler", "WebGL2RenderingContext", "bindSampler", "WebGLSampler");
    }
    impl.bindSampler(WTFMove(unit), sampler);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionSamplerParameteri(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "samplerParameteri");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLSampler* sampler = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        sampler = JSWebGLSampler::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!sampler))
            return throwArgumentTypeError(*state, 0, "sampler", "WebGL2RenderingContext", "samplerParameteri", "WebGLSampler");
    }
    auto pname = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto param = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.samplerParameteri(sampler, WTFMove(pname), WTFMove(param));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionSamplerParameterf(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "samplerParameterf");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLSampler* sampler = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        sampler = JSWebGLSampler::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!sampler))
            return throwArgumentTypeError(*state, 0, "sampler", "WebGL2RenderingContext", "samplerParameterf", "WebGLSampler");
    }
    auto pname = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto param = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.samplerParameterf(sampler, WTFMove(pname), WTFMove(param));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetSamplerParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getSamplerParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    return JSValue::encode(castedThis->getSamplerParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionFenceSync(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "fenceSync");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto condition = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto flags = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.fenceSync(WTFMove(condition), WTFMove(flags)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsSync(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "isSync");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLSync* sync = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        sync = JSWebGLSync::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!sync))
            return throwArgumentTypeError(*state, 0, "sync", "WebGL2RenderingContext", "isSync", "WebGLSync");
    }
    JSValue result = jsBoolean(impl.isSync(sync));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteSync(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "deleteSync");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLSync* sync = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        sync = JSWebGLSync::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!sync))
            return throwArgumentTypeError(*state, 0, "sync", "WebGL2RenderingContext", "deleteSync", "WebGLSync");
    }
    impl.deleteSync(sync);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionClientWaitSync(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "clientWaitSync");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLSync* sync = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        sync = JSWebGLSync::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!sync))
            return throwArgumentTypeError(*state, 0, "sync", "WebGL2RenderingContext", "clientWaitSync", "WebGLSync");
    }
    auto flags = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto timeout = convert<uint64_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsNumber(impl.clientWaitSync(sync, WTFMove(flags), WTFMove(timeout)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionWaitSync(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "waitSync");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLSync* sync = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        sync = JSWebGLSync::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!sync))
            return throwArgumentTypeError(*state, 0, "sync", "WebGL2RenderingContext", "waitSync", "WebGLSync");
    }
    auto flags = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto timeout = convert<uint64_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.waitSync(sync, WTFMove(flags), WTFMove(timeout));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetSyncParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getSyncParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    return JSValue::encode(castedThis->getSyncParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateTransformFeedback(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "createTransformFeedback");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.createTransformFeedback());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteTransformFeedback(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "deleteTransformFeedback");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLTransformFeedback* id = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        id = JSWebGLTransformFeedback::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!id))
            return throwArgumentTypeError(*state, 0, "id", "WebGL2RenderingContext", "deleteTransformFeedback", "WebGLTransformFeedback");
    }
    impl.deleteTransformFeedback(id);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsTransformFeedback(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "isTransformFeedback");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLTransformFeedback* id = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        id = JSWebGLTransformFeedback::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!id))
            return throwArgumentTypeError(*state, 0, "id", "WebGL2RenderingContext", "isTransformFeedback", "WebGLTransformFeedback");
    }
    JSValue result = jsBoolean(impl.isTransformFeedback(id));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindTransformFeedback(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "bindTransformFeedback");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    WebGLTransformFeedback* id = nullptr;
    if (!state->argument(1).isUndefinedOrNull()) {
        id = JSWebGLTransformFeedback::toWrapped(state->uncheckedArgument(1));
        if (UNLIKELY(!id))
            return throwArgumentTypeError(*state, 1, "id", "WebGL2RenderingContext", "bindTransformFeedback", "WebGLTransformFeedback");
    }
    impl.bindTransformFeedback(WTFMove(target), id);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBeginTransformFeedback(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "beginTransformFeedback");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto primitiveMode = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.beginTransformFeedback(WTFMove(primitiveMode));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionEndTransformFeedback(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "endTransformFeedback");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    impl.endTransformFeedback();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionTransformFeedbackVaryings(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "transformFeedbackVaryings");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGL2RenderingContext", "transformFeedbackVaryings", "WebGLProgram");
    }
    auto varyings = toNativeArray<String>(state, state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto bufferMode = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.transformFeedbackVaryings(program, WTFMove(varyings), WTFMove(bufferMode));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetTransformFeedbackVarying(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getTransformFeedbackVarying");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGL2RenderingContext", "getTransformFeedbackVarying", "WebGLProgram");
    }
    auto index = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getTransformFeedbackVarying(program, WTFMove(index)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionPauseTransformFeedback(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "pauseTransformFeedback");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    impl.pauseTransformFeedback();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionResumeTransformFeedback(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "resumeTransformFeedback");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    impl.resumeTransformFeedback();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindBufferBase(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "bindBufferBase");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto index = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    WebGLBuffer* buffer = nullptr;
    if (!state->argument(2).isUndefinedOrNull()) {
        buffer = JSWebGLBuffer::toWrapped(state->uncheckedArgument(2));
        if (UNLIKELY(!buffer))
            return throwArgumentTypeError(*state, 2, "buffer", "WebGL2RenderingContext", "bindBufferBase", "WebGLBuffer");
    }
    impl.bindBufferBase(WTFMove(target), WTFMove(index), buffer);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindBufferRange(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "bindBufferRange");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto index = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    WebGLBuffer* buffer = nullptr;
    if (!state->argument(2).isUndefinedOrNull()) {
        buffer = JSWebGLBuffer::toWrapped(state->uncheckedArgument(2));
        if (UNLIKELY(!buffer))
            return throwArgumentTypeError(*state, 2, "buffer", "WebGL2RenderingContext", "bindBufferRange", "WebGLBuffer");
    }
    auto offset = convert<int64_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto size = convert<int64_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.bindBufferRange(WTFMove(target), WTFMove(index), buffer, WTFMove(offset), WTFMove(size));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetIndexedParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getIndexedParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    return JSValue::encode(castedThis->getIndexedParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetUniformIndices(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getUniformIndices");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGL2RenderingContext", "getUniformIndices", "WebGLProgram");
    }
    auto uniformNames = toNativeArray<String>(state, state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getUniformIndices(program, WTFMove(uniformNames)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniforms(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getActiveUniforms");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGL2RenderingContext", "getActiveUniforms", "WebGLProgram");
    }
    auto uniformIndices = toUint32Array(state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto pname = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getActiveUniforms(program, WTFMove(uniformIndices), WTFMove(pname)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetUniformBlockIndex(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getUniformBlockIndex");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGL2RenderingContext", "getUniformBlockIndex", "WebGLProgram");
    }
    auto uniformBlockName = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsNumber(impl.getUniformBlockIndex(program, WTFMove(uniformBlockName)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getActiveUniformBlockParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    return JSValue::encode(castedThis->getActiveUniformBlockParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionGetActiveUniformBlockName(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "getActiveUniformBlockName");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    return JSValue::encode(castedThis->getActiveUniformBlockName(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionUniformBlockBinding(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "uniformBlockBinding");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGL2RenderingContext", "uniformBlockBinding", "WebGLProgram");
    }
    auto uniformBlockIndex = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto uniformBlockBinding = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniformBlockBinding(program, WTFMove(uniformBlockIndex), WTFMove(uniformBlockBinding));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionCreateVertexArray(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "createVertexArray");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.createVertexArray());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionDeleteVertexArray(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "deleteVertexArray");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLVertexArrayObject* vertexArray = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        vertexArray = JSWebGLVertexArrayObject::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!vertexArray))
            return throwArgumentTypeError(*state, 0, "vertexArray", "WebGL2RenderingContext", "deleteVertexArray", "WebGLVertexArrayObject");
    }
    impl.deleteVertexArray(vertexArray);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionIsVertexArray(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "isVertexArray");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLVertexArrayObject* vertexArray = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        vertexArray = JSWebGLVertexArrayObject::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!vertexArray))
            return throwArgumentTypeError(*state, 0, "vertexArray", "WebGL2RenderingContext", "isVertexArray", "WebGLVertexArrayObject");
    }
    JSValue result = jsBoolean(impl.isVertexArray(vertexArray));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGL2RenderingContextPrototypeFunctionBindVertexArray(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGL2RenderingContext*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGL2RenderingContext", "bindVertexArray");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGL2RenderingContext::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLVertexArrayObject* vertexArray = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        vertexArray = JSWebGLVertexArrayObject::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!vertexArray))
            return throwArgumentTypeError(*state, 0, "vertexArray", "WebGL2RenderingContext", "bindVertexArray", "WebGLVertexArrayObject");
    }
    impl.bindVertexArray(vertexArray);
    return JSValue::encode(jsUndefined());
}

void JSWebGL2RenderingContext::visitChildren(JSCell* cell, SlotVisitor& visitor)
{
    auto* thisObject = jsCast<JSWebGL2RenderingContext*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    thisObject->visitAdditionalChildren(visitor);
}


}

#endif // ENABLE(WEBGL2)
