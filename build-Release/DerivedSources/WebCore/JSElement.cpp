/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"
#include "JSElement.h"

#include "Attr.h"
#include "ClientRect.h"
#include "ClientRectList.h"
#include "CustomElementReactionQueue.h"
#include "Element.h"
#include "EventNames.h"
#include "ExceptionCode.h"
#include "HTMLCollection.h"
#include "HTMLNames.h"
#include "JSAttr.h"
#include "JSCSSStyleDeclaration.h"
#include "JSClientRect.h"
#include "JSClientRectList.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructor.h"
#include "JSDOMConvert.h"
#include "JSDOMTokenList.h"
#include "JSElement.h"
#include "JSEventListener.h"
#include "JSHTMLCollection.h"
#include "JSHTMLSlotElement.h"
#include "JSNamedNodeMap.h"
#include "JSNodeList.h"
#include "JSRange.h"
#include "JSShadowRoot.h"
#include "JSWebAnimation.h"
#include "NameNodeList.h"
#include "NodeList.h"
#include "Range.h"
#include "RuntimeEnabledFeatures.h"
#include "ShadowRoot.h"
#include "StyleProperties.h"
#include "URL.h"
#include "WebAnimation.h"
#include <runtime/Error.h>
#include <runtime/JSArray.h>
#include <runtime/JSString.h>
#include <runtime/ObjectConstructor.h>
#include <wtf/GetPtr.h>

using namespace JSC;

namespace WebCore {

template<typename T> Optional<T> parse(ExecState&, JSValue);
template<typename T> const char* expectedEnumerationValues();

JSString* jsStringWithCache(ExecState*, Element::ShadowRootMode);

JSString* jsStringWithCache(ExecState* state, Element::ShadowRootMode enumerationValue)
{
    static NeverDestroyed<const String> values[] = {
        ASCIILiteral("open"),
        ASCIILiteral("closed"),
    };
    static_assert(static_cast<size_t>(Element::ShadowRootMode::Open) == 0, "Element::ShadowRootMode::Open is not 0 as expected");
    static_assert(static_cast<size_t>(Element::ShadowRootMode::Closed) == 1, "Element::ShadowRootMode::Closed is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < WTF_ARRAY_LENGTH(values));
    return jsStringWithCache(state, values[static_cast<size_t>(enumerationValue)]);
}

template<> struct JSValueTraits<Element::ShadowRootMode> {
    static JSString* arrayJSValue(ExecState* state, JSDOMGlobalObject*, Element::ShadowRootMode value) { return jsStringWithCache(state, value); }
};

template<> Optional<Element::ShadowRootMode> parse<Element::ShadowRootMode>(ExecState& state, JSValue value)
{
    auto stringValue = value.toWTFString(&state);
    if (stringValue == "open")
        return Element::ShadowRootMode::Open;
    if (stringValue == "closed")
        return Element::ShadowRootMode::Closed;
    return Nullopt;
}

template<> Element::ShadowRootMode convert<Element::ShadowRootMode>(ExecState& state, JSValue value)
{
    auto result = parse<Element::ShadowRootMode>(state, value);
    if (UNLIKELY(!result)) {
        throwTypeError(&state);
        return { };
    }
    return result.value();
}

template<> inline const char* expectedEnumerationValues<Element::ShadowRootMode>()
{
    return "\"open\", \"closed\"";
}

template<> Optional<Element::ShadowRootInit> convertDictionary<Element::ShadowRootInit>(ExecState& state, JSValue value)
{
    auto* object = value.getObject();
    if (UNLIKELY(!object || object->type() == RegExpObjectType)) {
        throwTypeError(&state);
        return Nullopt;
    }
    auto mode = convert<Element::ShadowRootMode>(state, object->get(&state, Identifier::fromString(&state, "mode")));
    return Element::ShadowRootInit { WTFMove(mode) };
}

// Functions

JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttribute(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttribute(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttribute(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNode(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNode(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNode(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagName(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributes(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagNameNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNodeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNodeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttribute(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributeNS(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoView(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNames(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoViewIfNeeded(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByLines(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByPages(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByClassName(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionMatches(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionClosest(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitMatchesSelector(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetClientRects(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetBoundingClientRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullScreen(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullscreen(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentElement(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentHTML(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentText(JSC::ExecState*);
#if ENABLE(POINTER_LOCK)
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRequestPointerLock(JSC::ExecState*);
#endif
#if ENABLE(CSS_REGIONS)
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitGetRegionFlowRanges(JSC::ExecState*);
#endif
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAttachShadow(JSC::ExecState*);
#if ENABLE(WEB_ANIMATIONS)
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAnimations(JSC::ExecState*);
#endif
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionBefore(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAfter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionReplaceWith(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemove(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionPrepend(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAppend(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelector(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelectorAll(JSC::ExecState*);

// Attributes

JSC::EncodedJSValue jsElementTagName(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementAttributes(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementStyle(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementId(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementId(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementNamespaceURI(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementPrefix(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementLocalName(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementOffsetLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementOffsetTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementOffsetWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementOffsetHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementClientLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementClientTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementClientWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementClientHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementScrollLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementScrollLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementScrollTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementScrollTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementScrollWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementScrollHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementOffsetParent(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementInnerHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementInnerHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOuterHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOuterHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementClassName(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementClassName(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementClassList(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementClassList(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(CSS_REGIONS)
JSC::EncodedJSValue jsElementWebkitRegionOverset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
#endif
JSC::EncodedJSValue jsElementShadowRoot(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementSlot(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementSlot(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnbeforecopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnbeforecopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnbeforecut(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnbeforecut(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnbeforepaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnbeforepaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOncopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOncopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOncut(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOncut(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnpaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnpaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnselectstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnselectstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(FULLSCREEN_API)
JSC::EncodedJSValue jsElementOnwebkitfullscreenchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitfullscreenchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(FULLSCREEN_API)
JSC::EncodedJSValue jsElementOnwebkitfullscreenerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitfullscreenerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
JSC::EncodedJSValue jsElementOnanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOntransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOntransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnwebkitanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnwebkitanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnwebkitanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnwebkittransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkittransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(IOS_GESTURE_EVENTS)
JSC::EncodedJSValue jsElementOngesturechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOngesturechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(IOS_GESTURE_EVENTS)
JSC::EncodedJSValue jsElementOngestureend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOngestureend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(IOS_GESTURE_EVENTS)
JSC::EncodedJSValue jsElementOngesturestart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOngesturestart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
JSC::EncodedJSValue jsElementOnfocusin(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnfocusin(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnfocusout(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnfocusout(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsElementOnbeforeload(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnbeforeload(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#if ENABLE(ENCRYPTED_MEDIA)
JSC::EncodedJSValue jsElementOnwebkitkeyadded(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitkeyadded(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(ENCRYPTED_MEDIA)
JSC::EncodedJSValue jsElementOnwebkitkeyerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitkeyerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(ENCRYPTED_MEDIA)
JSC::EncodedJSValue jsElementOnwebkitkeymessage(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitkeymessage(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)
JSC::EncodedJSValue jsElementOnwebkitneedkey(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitneedkey(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(VIDEO_PRESENTATION_MODE)
JSC::EncodedJSValue jsElementOnwebkitpresentationmodechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitpresentationmodechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
JSC::EncodedJSValue jsElementOnwebkitcurrentplaybacktargetiswirelesschanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitcurrentplaybacktargetiswirelesschanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
JSC::EncodedJSValue jsElementOnwebkitplaybacktargetavailabilitychanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementOnwebkitplaybacktargetavailabilitychanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
#endif
JSC::EncodedJSValue jsElementPreviousElementSibling(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementNextElementSibling(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementChildren(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementFirstElementChild(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementLastElementChild(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementChildElementCount(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementAssignedSlot(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);

class JSElementPrototype : public JSC::JSNonFinalObject {
public:
    typedef JSC::JSNonFinalObject Base;
    static JSElementPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSElementPrototype* ptr = new (NotNull, JSC::allocateCell<JSElementPrototype>(vm.heap)) JSElementPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSElementPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};

typedef JSDOMConstructorNotConstructable<JSElement> JSElementConstructor;

/* Hash table for constructor */

static const HashTableValue JSElementConstructorTableValues[] =
{
    { "ALLOW_KEYBOARD_INPUT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
};

static_assert(Element::ALLOW_KEYBOARD_INPUT == 1, "ALLOW_KEYBOARD_INPUT in Element does not match value from IDL");

template<> JSValue JSElementConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    return JSNode::getConstructor(vm, &globalObject);
}

template<> void JSElementConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->prototype, JSElement::prototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("Element"))), ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
    reifyStaticProperties(vm, JSElementConstructorTableValues, *this);
}

template<> const ClassInfo JSElementConstructor::s_info = { "Element", &Base::s_info, 0, CREATE_METHOD_TABLE(JSElementConstructor) };

/* Hash table for prototype */

static const HashTableValue JSElementPrototypeTableValues[] =
{
    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementConstructor) } },
    { "tagName", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementTagName), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "attributes", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementAttributes), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "style", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementStyle), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "id", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementId), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementId) } },
    { "namespaceURI", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementNamespaceURI), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "prefix", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementPrefix), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "localName", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementLocalName), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "offsetLeft", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetLeft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "offsetTop", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetTop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "offsetWidth", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "offsetHeight", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "clientLeft", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientLeft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "clientTop", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientTop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "clientWidth", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "clientHeight", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "scrollLeft", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollLeft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementScrollLeft) } },
    { "scrollTop", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollTop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementScrollTop) } },
    { "scrollWidth", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "scrollHeight", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "offsetParent", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetParent), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "innerHTML", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementInnerHTML), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementInnerHTML) } },
    { "outerHTML", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOuterHTML), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOuterHTML) } },
    { "className", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClassName), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementClassName) } },
    { "classList", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClassList), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementClassList) } },
#if ENABLE(CSS_REGIONS)
    { "webkitRegionOverset", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementWebkitRegionOverset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "shadowRoot", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementShadowRoot), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "slot", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementSlot), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementSlot) } },
    { "onbeforecopy", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforecopy), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforecopy) } },
    { "onbeforecut", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforecut), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforecut) } },
    { "onbeforepaste", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforepaste), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforepaste) } },
    { "oncopy", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOncopy), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOncopy) } },
    { "oncut", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOncut), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOncut) } },
    { "onpaste", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnpaste), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnpaste) } },
    { "onselectstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnselectstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnselectstart) } },
#if ENABLE(FULLSCREEN_API)
    { "onwebkitfullscreenchange", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitfullscreenchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitfullscreenchange) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(FULLSCREEN_API)
    { "onwebkitfullscreenerror", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitfullscreenerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitfullscreenerror) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "onanimationend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnanimationend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnanimationend) } },
    { "onanimationiteration", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnanimationiteration), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnanimationiteration) } },
    { "onanimationstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnanimationstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnanimationstart) } },
    { "ontransitionend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOntransitionend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOntransitionend) } },
    { "onwebkitanimationend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitanimationend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitanimationend) } },
    { "onwebkitanimationiteration", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitanimationiteration), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitanimationiteration) } },
    { "onwebkitanimationstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitanimationstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitanimationstart) } },
    { "onwebkittransitionend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkittransitionend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkittransitionend) } },
#if ENABLE(IOS_GESTURE_EVENTS)
    { "ongesturechange", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOngesturechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOngesturechange) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(IOS_GESTURE_EVENTS)
    { "ongestureend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOngestureend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOngestureend) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(IOS_GESTURE_EVENTS)
    { "ongesturestart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOngesturestart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOngesturestart) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "onfocusin", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnfocusin), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnfocusin) } },
    { "onfocusout", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnfocusout), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnfocusout) } },
    { "onbeforeload", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforeload), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforeload) } },
#if ENABLE(ENCRYPTED_MEDIA)
    { "onwebkitkeyadded", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitkeyadded), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitkeyadded) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    { "onwebkitkeyerror", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitkeyerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitkeyerror) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(ENCRYPTED_MEDIA)
    { "onwebkitkeymessage", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitkeymessage), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitkeymessage) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)
    { "onwebkitneedkey", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitneedkey), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitneedkey) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(VIDEO_PRESENTATION_MODE)
    { "onwebkitpresentationmodechanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitpresentationmodechanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitpresentationmodechanged) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
    { "onwebkitcurrentplaybacktargetiswirelesschanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitcurrentplaybacktargetiswirelesschanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitcurrentplaybacktargetiswirelesschanged) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(WIRELESS_PLAYBACK_TARGET)
    { "onwebkitplaybacktargetavailabilitychanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitplaybacktargetavailabilitychanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitplaybacktargetavailabilitychanged) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "previousElementSibling", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementPreviousElementSibling), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "nextElementSibling", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementNextElementSibling), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "children", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementChildren), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "firstElementChild", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementFirstElementChild), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "lastElementChild", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementLastElementChild), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "childElementCount", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementChildElementCount), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "assignedSlot", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementAssignedSlot), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "getAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttribute), (intptr_t) (1) } },
    { "setAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttribute), (intptr_t) (2) } },
    { "removeAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemoveAttribute), (intptr_t) (1) } },
    { "getAttributeNode", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNode), (intptr_t) (1) } },
    { "setAttributeNode", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttributeNode), (intptr_t) (1) } },
    { "removeAttributeNode", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemoveAttributeNode), (intptr_t) (1) } },
    { "getElementsByTagName", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetElementsByTagName), (intptr_t) (1) } },
    { "hasAttributes", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionHasAttributes), (intptr_t) (0) } },
    { "getAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNS), (intptr_t) (2) } },
    { "setAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttributeNS), (intptr_t) (3) } },
    { "removeAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemoveAttributeNS), (intptr_t) (2) } },
    { "getElementsByTagNameNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetElementsByTagNameNS), (intptr_t) (2) } },
    { "getAttributeNodeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNodeNS), (intptr_t) (2) } },
    { "setAttributeNodeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttributeNodeNS), (intptr_t) (1) } },
    { "hasAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionHasAttribute), (intptr_t) (1) } },
    { "hasAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionHasAttributeNS), (intptr_t) (2) } },
    { "scrollIntoView", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollIntoView), (intptr_t) (0) } },
    { "getAttributeNames", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNames), (intptr_t) (0) } },
    { "scrollIntoViewIfNeeded", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollIntoViewIfNeeded), (intptr_t) (0) } },
    { "scrollByLines", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollByLines), (intptr_t) (0) } },
    { "scrollByPages", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollByPages), (intptr_t) (0) } },
    { "getElementsByClassName", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetElementsByClassName), (intptr_t) (1) } },
    { "matches", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionMatches), (intptr_t) (1) } },
    { "closest", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionClosest), (intptr_t) (1) } },
    { "webkitMatchesSelector", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitMatchesSelector), (intptr_t) (1) } },
    { "getClientRects", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetClientRects), (intptr_t) (0) } },
    { "getBoundingClientRect", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetBoundingClientRect), (intptr_t) (0) } },
    { "webkitRequestFullScreen", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitRequestFullScreen), (intptr_t) (0) } },
    { "webkitRequestFullscreen", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitRequestFullscreen), (intptr_t) (0) } },
    { "insertAdjacentElement", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionInsertAdjacentElement), (intptr_t) (2) } },
    { "insertAdjacentHTML", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionInsertAdjacentHTML), (intptr_t) (2) } },
    { "insertAdjacentText", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionInsertAdjacentText), (intptr_t) (2) } },
#if ENABLE(POINTER_LOCK)
    { "requestPointerLock", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRequestPointerLock), (intptr_t) (0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
#if ENABLE(CSS_REGIONS)
    { "webkitGetRegionFlowRanges", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitGetRegionFlowRanges), (intptr_t) (0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "attachShadow", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionAttachShadow), (intptr_t) (1) } },
#if ENABLE(WEB_ANIMATIONS)
    { "getAnimations", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAnimations), (intptr_t) (0) } },
#else
    { 0, 0, NoIntrinsic, { 0, 0 } },
#endif
    { "before", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionBefore), (intptr_t) (0) } },
    { "after", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionAfter), (intptr_t) (0) } },
    { "replaceWith", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionReplaceWith), (intptr_t) (0) } },
    { "remove", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemove), (intptr_t) (0) } },
    { "prepend", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionPrepend), (intptr_t) (0) } },
    { "append", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionAppend), (intptr_t) (0) } },
    { "querySelector", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionQuerySelector), (intptr_t) (1) } },
    { "querySelectorAll", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionQuerySelectorAll), (intptr_t) (1) } },
    { "ALLOW_KEYBOARD_INPUT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
};

const ClassInfo JSElementPrototype::s_info = { "ElementPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSElementPrototype) };

void JSElementPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSElementPrototypeTableValues, *this);
    if (!RuntimeEnabledFeatures::sharedFeatures().shadowDOMEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("attachShadow"), strlen("attachShadow"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
    if (!RuntimeEnabledFeatures::sharedFeatures().shadowDOMEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("shadowRoot"), strlen("shadowRoot"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
    if (!RuntimeEnabledFeatures::sharedFeatures().shadowDOMEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("slot"), strlen("slot"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
    if (!RuntimeEnabledFeatures::sharedFeatures().shadowDOMEnabled()) {
        Identifier propertyName = Identifier::fromString(&vm, reinterpret_cast<const LChar*>("assignedSlot"), strlen("assignedSlot"));
        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);
        JSObject::deleteProperty(this, globalObject()->globalExec(), propertyName);
    }
    JSObject& unscopables = *constructEmptyObject(globalObject()->globalExec(), globalObject()->nullPrototypeObjectStructure());
    unscopables.putDirect(vm, Identifier::fromString(&vm, "before"), jsBoolean(true));
    unscopables.putDirect(vm, Identifier::fromString(&vm, "after"), jsBoolean(true));
    unscopables.putDirect(vm, Identifier::fromString(&vm, "replaceWith"), jsBoolean(true));
    unscopables.putDirect(vm, Identifier::fromString(&vm, "remove"), jsBoolean(true));
    unscopables.putDirect(vm, Identifier::fromString(&vm, "prepend"), jsBoolean(true));
    unscopables.putDirect(vm, Identifier::fromString(&vm, "append"), jsBoolean(true));
    putDirectWithoutTransition(vm, vm.propertyNames->unscopablesSymbol, &unscopables, DontEnum | ReadOnly);
}

const ClassInfo JSElement::s_info = { "Element", &Base::s_info, 0, CREATE_METHOD_TABLE(JSElement) };

JSElement::JSElement(Structure* structure, JSDOMGlobalObject& globalObject, Ref<Element>&& impl)
    : JSNode(structure, globalObject, WTFMove(impl))
{
}

JSObject* JSElement::createPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return JSElementPrototype::create(vm, globalObject, JSElementPrototype::createStructure(vm, globalObject, JSNode::prototype(vm, globalObject)));
}

JSObject* JSElement::prototype(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSElement>(vm, globalObject);
}

EncodedJSValue jsElementTagName(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "tagName");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringOrNull(state, impl.tagName());
    return JSValue::encode(result);
}


EncodedJSValue jsElementAttributes(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "attributes");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.attributes());
    return JSValue::encode(result);
}


EncodedJSValue jsElementStyle(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "style");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.cssomStyle());
    return JSValue::encode(result);
}


EncodedJSValue jsElementId(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "id");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.getIdAttribute());
    return JSValue::encode(result);
}


EncodedJSValue jsElementNamespaceURI(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "namespaceURI");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringOrNull(state, impl.namespaceURI());
    return JSValue::encode(result);
}


EncodedJSValue jsElementPrefix(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "prefix");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringOrNull(state, impl.prefix());
    return JSValue::encode(result);
}


EncodedJSValue jsElementLocalName(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "localName");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.localName());
    return JSValue::encode(result);
}


EncodedJSValue jsElementOffsetLeft(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "offsetLeft");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.offsetLeft());
    return JSValue::encode(result);
}


EncodedJSValue jsElementOffsetTop(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "offsetTop");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.offsetTop());
    return JSValue::encode(result);
}


EncodedJSValue jsElementOffsetWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "offsetWidth");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.offsetWidth());
    return JSValue::encode(result);
}


EncodedJSValue jsElementOffsetHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "offsetHeight");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.offsetHeight());
    return JSValue::encode(result);
}


EncodedJSValue jsElementClientLeft(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "clientLeft");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.clientLeft());
    return JSValue::encode(result);
}


EncodedJSValue jsElementClientTop(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "clientTop");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.clientTop());
    return JSValue::encode(result);
}


EncodedJSValue jsElementClientWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "clientWidth");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.clientWidth());
    return JSValue::encode(result);
}


EncodedJSValue jsElementClientHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "clientHeight");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.clientHeight());
    return JSValue::encode(result);
}


EncodedJSValue jsElementScrollLeft(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "scrollLeft");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.scrollLeft());
    return JSValue::encode(result);
}


EncodedJSValue jsElementScrollTop(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "scrollTop");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.scrollTop());
    return JSValue::encode(result);
}


EncodedJSValue jsElementScrollWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "scrollWidth");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.scrollWidth());
    return JSValue::encode(result);
}


EncodedJSValue jsElementScrollHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "scrollHeight");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.scrollHeight());
    return JSValue::encode(result);
}


EncodedJSValue jsElementOffsetParent(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "offsetParent");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.bindingsOffsetParent());
    return JSValue::encode(result);
}


EncodedJSValue jsElementInnerHTML(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "innerHTML");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.innerHTML());
    return JSValue::encode(result);
}


EncodedJSValue jsElementOuterHTML(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "outerHTML");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.outerHTML());
    return JSValue::encode(result);
}


EncodedJSValue jsElementClassName(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "className");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.attributeWithoutSynchronization(WebCore::HTMLNames::classAttr));
    return JSValue::encode(result);
}


EncodedJSValue jsElementClassList(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "classList");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.classList());
    return JSValue::encode(result);
}


#if ENABLE(CSS_REGIONS)
EncodedJSValue jsElementWebkitRegionOverset(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "webkitRegionOverset");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.webkitRegionOverset());
    return JSValue::encode(result);
}

#endif

EncodedJSValue jsElementShadowRoot(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "shadowRoot");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.shadowRootForBindings(*state));
    return JSValue::encode(result);
}


EncodedJSValue jsElementSlot(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "slot");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.attributeWithoutSynchronization(WebCore::HTMLNames::slotAttr));
    return JSValue::encode(result);
}


EncodedJSValue jsElementOnbeforecopy(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onbeforecopy");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().beforecopyEvent));
}


EncodedJSValue jsElementOnbeforecut(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onbeforecut");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().beforecutEvent));
}


EncodedJSValue jsElementOnbeforepaste(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onbeforepaste");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().beforepasteEvent));
}


EncodedJSValue jsElementOncopy(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "oncopy");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().copyEvent));
}


EncodedJSValue jsElementOncut(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "oncut");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().cutEvent));
}


EncodedJSValue jsElementOnpaste(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onpaste");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().pasteEvent));
}


EncodedJSValue jsElementOnselectstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onselectstart");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().selectstartEvent));
}


#if ENABLE(FULLSCREEN_API)
EncodedJSValue jsElementOnwebkitfullscreenchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitfullscreenchange");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitfullscreenchangeEvent));
}

#endif

#if ENABLE(FULLSCREEN_API)
EncodedJSValue jsElementOnwebkitfullscreenerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitfullscreenerror");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitfullscreenerrorEvent));
}

#endif

EncodedJSValue jsElementOnanimationend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onanimationend");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().animationendEvent));
}


EncodedJSValue jsElementOnanimationiteration(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onanimationiteration");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().animationiterationEvent));
}


EncodedJSValue jsElementOnanimationstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onanimationstart");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().animationstartEvent));
}


EncodedJSValue jsElementOntransitionend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "ontransitionend");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().transitionendEvent));
}


EncodedJSValue jsElementOnwebkitanimationend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitanimationend");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitAnimationEndEvent));
}


EncodedJSValue jsElementOnwebkitanimationiteration(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitanimationiteration");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitAnimationIterationEvent));
}


EncodedJSValue jsElementOnwebkitanimationstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitanimationstart");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitAnimationStartEvent));
}


EncodedJSValue jsElementOnwebkittransitionend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkittransitionend");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitTransitionEndEvent));
}


#if ENABLE(IOS_GESTURE_EVENTS)
EncodedJSValue jsElementOngesturechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "ongesturechange");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().gesturechangeEvent));
}

#endif

#if ENABLE(IOS_GESTURE_EVENTS)
EncodedJSValue jsElementOngestureend(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "ongestureend");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().gestureendEvent));
}

#endif

#if ENABLE(IOS_GESTURE_EVENTS)
EncodedJSValue jsElementOngesturestart(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "ongesturestart");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().gesturestartEvent));
}

#endif

EncodedJSValue jsElementOnfocusin(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onfocusin");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().focusinEvent));
}


EncodedJSValue jsElementOnfocusout(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onfocusout");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().focusoutEvent));
}


EncodedJSValue jsElementOnbeforeload(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onbeforeload");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().beforeloadEvent));
}


#if ENABLE(ENCRYPTED_MEDIA)
EncodedJSValue jsElementOnwebkitkeyadded(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitkeyadded");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitkeyaddedEvent));
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
EncodedJSValue jsElementOnwebkitkeyerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitkeyerror");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitkeyerrorEvent));
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
EncodedJSValue jsElementOnwebkitkeymessage(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitkeymessage");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitkeymessageEvent));
}

#endif

#if ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)
EncodedJSValue jsElementOnwebkitneedkey(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitneedkey");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitneedkeyEvent));
}

#endif

#if ENABLE(VIDEO_PRESENTATION_MODE)
EncodedJSValue jsElementOnwebkitpresentationmodechanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitpresentationmodechanged");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitpresentationmodechangedEvent));
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
EncodedJSValue jsElementOnwebkitcurrentplaybacktargetiswirelesschanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitcurrentplaybacktargetiswirelesschanged");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent));
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
EncodedJSValue jsElementOnwebkitplaybacktargetavailabilitychanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "onwebkitplaybacktargetavailabilitychanged");
    }
    UNUSED_PARAM(state);
    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitplaybacktargetavailabilitychangedEvent));
}

#endif

EncodedJSValue jsElementPreviousElementSibling(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "previousElementSibling");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.previousElementSibling());
    return JSValue::encode(result);
}


EncodedJSValue jsElementNextElementSibling(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "nextElementSibling");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.nextElementSibling());
    return JSValue::encode(result);
}


EncodedJSValue jsElementChildren(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "children");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.children());
    return JSValue::encode(result);
}


EncodedJSValue jsElementFirstElementChild(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "firstElementChild");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.firstElementChild());
    return JSValue::encode(result);
}


EncodedJSValue jsElementLastElementChild(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "lastElementChild");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.lastElementChild());
    return JSValue::encode(result);
}


EncodedJSValue jsElementChildElementCount(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "childElementCount");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.childElementCount());
    return JSValue::encode(result);
}


EncodedJSValue jsElementAssignedSlot(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsElementCast(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "Element", "assignedSlot");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.assignedSlotForBindings());
    return JSValue::encode(result);
}


EncodedJSValue jsElementConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    JSElementPrototype* domObject = jsDynamicCast<JSElementPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject))
        return throwVMTypeError(state);
    return JSValue::encode(JSElement::getConstructor(state->vm(), domObject->globalObject()));
}

bool setJSElementConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    JSElementPrototype* domObject = jsDynamicCast<JSElementPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject)) {
        throwVMTypeError(state);
        return false;
    }
    // Shadowing a built-in constructor
    return domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
}

bool setJSElementId(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "id");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::idAttr, WTFMove(nativeValue));
    return true;
}


bool setJSElementScrollLeft(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "scrollLeft");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = convert<int32_t>(*state, value, NormalConversion);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setScrollLeft(WTFMove(nativeValue));
    return true;
}


bool setJSElementScrollTop(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "scrollTop");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = convert<int32_t>(*state, value, NormalConversion);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setScrollTop(WTFMove(nativeValue));
    return true;
}


bool setJSElementInnerHTML(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "innerHTML");
    }
    auto& impl = castedThis->wrapped();
    ExceptionCode ec = 0;
    auto nativeValue = valueToStringTreatingNullAsEmptyString(state, value);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setInnerHTML(WTFMove(nativeValue), ec);
    setDOMException(state, ec);
    return true;
}


bool setJSElementOuterHTML(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "outerHTML");
    }
    auto& impl = castedThis->wrapped();
    ExceptionCode ec = 0;
    auto nativeValue = valueToStringTreatingNullAsEmptyString(state, value);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setOuterHTML(WTFMove(nativeValue), ec);
    setDOMException(state, ec);
    return true;
}


bool setJSElementClassName(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "className");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::classAttr, WTFMove(nativeValue));
    return true;
}


bool setJSElementClassList(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "classList");
    }
    Ref<DOMTokenList> forwardedImpl = castedThis->wrapped().classList();
    auto& impl = forwardedImpl.get();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setValue(WTFMove(nativeValue));
    return true;
}


bool setJSElementSlot(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "slot");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::slotAttr, WTFMove(nativeValue));
    return true;
}


bool setJSElementOnbeforecopy(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onbeforecopy");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().beforecopyEvent, value);
    return true;
}


bool setJSElementOnbeforecut(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onbeforecut");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().beforecutEvent, value);
    return true;
}


bool setJSElementOnbeforepaste(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onbeforepaste");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().beforepasteEvent, value);
    return true;
}


bool setJSElementOncopy(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "oncopy");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().copyEvent, value);
    return true;
}


bool setJSElementOncut(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "oncut");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().cutEvent, value);
    return true;
}


bool setJSElementOnpaste(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onpaste");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().pasteEvent, value);
    return true;
}


bool setJSElementOnselectstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onselectstart");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().selectstartEvent, value);
    return true;
}


#if ENABLE(FULLSCREEN_API)
bool setJSElementOnwebkitfullscreenchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitfullscreenchange");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitfullscreenchangeEvent, value);
    return true;
}

#endif

#if ENABLE(FULLSCREEN_API)
bool setJSElementOnwebkitfullscreenerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitfullscreenerror");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitfullscreenerrorEvent, value);
    return true;
}

#endif

bool setJSElementOnanimationend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onanimationend");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().animationendEvent, value);
    return true;
}


bool setJSElementOnanimationiteration(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onanimationiteration");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().animationiterationEvent, value);
    return true;
}


bool setJSElementOnanimationstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onanimationstart");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().animationstartEvent, value);
    return true;
}


bool setJSElementOntransitionend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "ontransitionend");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().transitionendEvent, value);
    return true;
}


bool setJSElementOnwebkitanimationend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitanimationend");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitAnimationEndEvent, value);
    return true;
}


bool setJSElementOnwebkitanimationiteration(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitanimationiteration");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitAnimationIterationEvent, value);
    return true;
}


bool setJSElementOnwebkitanimationstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitanimationstart");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitAnimationStartEvent, value);
    return true;
}


bool setJSElementOnwebkittransitionend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkittransitionend");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitTransitionEndEvent, value);
    return true;
}


#if ENABLE(IOS_GESTURE_EVENTS)
bool setJSElementOngesturechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "ongesturechange");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().gesturechangeEvent, value);
    return true;
}

#endif

#if ENABLE(IOS_GESTURE_EVENTS)
bool setJSElementOngestureend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "ongestureend");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().gestureendEvent, value);
    return true;
}

#endif

#if ENABLE(IOS_GESTURE_EVENTS)
bool setJSElementOngesturestart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "ongesturestart");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().gesturestartEvent, value);
    return true;
}

#endif

bool setJSElementOnfocusin(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onfocusin");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().focusinEvent, value);
    return true;
}


bool setJSElementOnfocusout(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onfocusout");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().focusoutEvent, value);
    return true;
}


bool setJSElementOnbeforeload(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onbeforeload");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().beforeloadEvent, value);
    return true;
}


#if ENABLE(ENCRYPTED_MEDIA)
bool setJSElementOnwebkitkeyadded(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitkeyadded");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitkeyaddedEvent, value);
    return true;
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
bool setJSElementOnwebkitkeyerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitkeyerror");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitkeyerrorEvent, value);
    return true;
}

#endif

#if ENABLE(ENCRYPTED_MEDIA)
bool setJSElementOnwebkitkeymessage(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitkeymessage");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitkeymessageEvent, value);
    return true;
}

#endif

#if ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)
bool setJSElementOnwebkitneedkey(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitneedkey");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitneedkeyEvent, value);
    return true;
}

#endif

#if ENABLE(VIDEO_PRESENTATION_MODE)
bool setJSElementOnwebkitpresentationmodechanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitpresentationmodechanged");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitpresentationmodechangedEvent, value);
    return true;
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
bool setJSElementOnwebkitcurrentplaybacktargetiswirelesschanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitcurrentplaybacktargetiswirelesschanged");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent, value);
    return true;
}

#endif

#if ENABLE(WIRELESS_PLAYBACK_TARGET)
bool setJSElementOnwebkitplaybacktargetavailabilitychanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "Element", "onwebkitplaybacktargetavailabilitychanged");
    }
    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitplaybacktargetavailabilitychangedEvent, value);
    return true;
}

#endif

JSValue JSElement::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSElementConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttribute(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "getAttribute");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto name = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsStringOrNull(state, impl.getAttribute(WTFMove(name)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttribute(ExecState* state)
{
#if ENABLE(CUSTOM_ELEMENTS)
    CustomElementReactionStack customElementReactionStack;
#endif
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "setAttribute");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto name = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto value = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setAttribute(WTFMove(name), WTFMove(value), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttribute(ExecState* state)
{
#if ENABLE(CUSTOM_ELEMENTS)
    CustomElementReactionStack customElementReactionStack;
#endif
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "removeAttribute");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto name = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.removeAttribute(WTFMove(name));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNode(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "getAttributeNode");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto name = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getAttributeNode(WTFMove(name)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNode(ExecState* state)
{
#if ENABLE(CUSTOM_ELEMENTS)
    CustomElementReactionStack customElementReactionStack;
#endif
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "setAttributeNode");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto newAttr = JSAttr::toWrapped(state->argument(0));
    if (UNLIKELY(!newAttr))
        return throwArgumentTypeError(*state, 0, "newAttr", "Element", "setAttributeNode", "Attr");
    JSValue result = toJS(state, castedThis->globalObject(), impl.setAttributeNode(*newAttr, ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNode(ExecState* state)
{
#if ENABLE(CUSTOM_ELEMENTS)
    CustomElementReactionStack customElementReactionStack;
#endif
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "removeAttributeNode");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto oldAttr = JSAttr::toWrapped(state->argument(0));
    if (UNLIKELY(!oldAttr))
        return throwArgumentTypeError(*state, 0, "oldAttr", "Element", "removeAttributeNode", "Attr");
    JSValue result = toJS(state, castedThis->globalObject(), impl.removeAttributeNode(*oldAttr, ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagName(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "getElementsByTagName");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto name = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getElementsByTagName(WTFMove(name)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributes(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "hasAttributes");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    JSValue result = jsBoolean(impl.hasAttributes());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNS(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "getAttributeNS");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto localName = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsStringOrNull(state, impl.getAttributeNS(WTFMove(namespaceURI), WTFMove(localName)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNS(ExecState* state)
{
#if ENABLE(CUSTOM_ELEMENTS)
    CustomElementReactionStack customElementReactionStack;
#endif
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "setAttributeNS");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto qualifiedName = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto value = state->argument(2).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setAttributeNS(WTFMove(namespaceURI), WTFMove(qualifiedName), WTFMove(value), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNS(ExecState* state)
{
#if ENABLE(CUSTOM_ELEMENTS)
    CustomElementReactionStack customElementReactionStack;
#endif
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "removeAttributeNS");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto localName = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.removeAttributeNS(WTFMove(namespaceURI), WTFMove(localName));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagNameNS(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "getElementsByTagNameNS");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto localName = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getElementsByTagNameNS(WTFMove(namespaceURI), WTFMove(localName)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNodeNS(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "getAttributeNodeNS");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto localName = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getAttributeNodeNS(WTFMove(namespaceURI), WTFMove(localName)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNodeNS(ExecState* state)
{
#if ENABLE(CUSTOM_ELEMENTS)
    CustomElementReactionStack customElementReactionStack;
#endif
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "setAttributeNodeNS");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto newAttr = JSAttr::toWrapped(state->argument(0));
    if (UNLIKELY(!newAttr))
        return throwArgumentTypeError(*state, 0, "newAttr", "Element", "setAttributeNodeNS", "Attr");
    JSValue result = toJS(state, castedThis->globalObject(), impl.setAttributeNodeNS(*newAttr, ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttribute(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "hasAttribute");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto name = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsBoolean(impl.hasAttribute(WTFMove(name)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributeNS(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "hasAttributeNS");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto localName = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsBoolean(impl.hasAttributeNS(WTFMove(namespaceURI), WTFMove(localName)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoView(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "scrollIntoView");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    auto alignWithTop = state->argument(0).isUndefined() ? true : state->uncheckedArgument(0).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.scrollIntoView(WTFMove(alignWithTop));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNames(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "getAttributeNames");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    JSValue result = jsArray(state, castedThis->globalObject(), impl.getAttributeNames());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoViewIfNeeded(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "scrollIntoViewIfNeeded");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    auto centerIfNeeded = state->argument(0).isUndefined() ? true : state->uncheckedArgument(0).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.scrollIntoViewIfNeeded(WTFMove(centerIfNeeded));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByLines(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "scrollByLines");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    auto lines = convert<int32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.scrollByLines(WTFMove(lines));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByPages(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "scrollByPages");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    auto pages = convert<int32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.scrollByPages(WTFMove(pages));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByClassName(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "getElementsByClassName");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto name = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getElementsByClassName(WTFMove(name)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionMatches(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "matches");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto selectors = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsBoolean(impl.matches(WTFMove(selectors), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionClosest(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "closest");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto selectors = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.closest(WTFMove(selectors), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitMatchesSelector(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "webkitMatchesSelector");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto selectors = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsBoolean(impl.matches(WTFMove(selectors), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetClientRects(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "getClientRects");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.getClientRects());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetBoundingClientRect(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "getBoundingClientRect");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.getBoundingClientRect());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullScreen(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "webkitRequestFullScreen");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    auto flags = convert<uint16_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.webkitRequestFullScreen(WTFMove(flags));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullscreen(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "webkitRequestFullscreen");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    impl.webkitRequestFullscreen();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentElement(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "insertAdjacentElement");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto where = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto element = JSElement::toWrapped(state->argument(1));
    if (UNLIKELY(!element))
        return throwArgumentTypeError(*state, 1, "element", "Element", "insertAdjacentElement", "Element");
    JSValue result = toJS(state, castedThis->globalObject(), impl.insertAdjacentElement(WTFMove(where), *element, ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentHTML(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "insertAdjacentHTML");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto where = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto html = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.insertAdjacentHTML(WTFMove(where), WTFMove(html), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionInsertAdjacentText(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "insertAdjacentText");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto where = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto text = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.insertAdjacentText(WTFMove(where), WTFMove(text), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

#if ENABLE(POINTER_LOCK)
EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRequestPointerLock(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "requestPointerLock");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    impl.requestPointerLock();
    return JSValue::encode(jsUndefined());
}

#endif

#if ENABLE(CSS_REGIONS)
EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitGetRegionFlowRanges(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "webkitGetRegionFlowRanges");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    JSValue result = jsArray(state, castedThis->globalObject(), impl.webkitGetRegionFlowRanges());
    return JSValue::encode(result);
}

#endif

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAttachShadow(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "attachShadow");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto init = convertDictionary<Element::ShadowRootInit>(*state, state->argument(0));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.attachShadow(init.value(), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

#if ENABLE(WEB_ANIMATIONS)
EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAnimations(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "getAnimations");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    JSValue result = jsArray(state, castedThis->globalObject(), impl.getAnimations());
    return JSValue::encode(result);
}

#endif

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionBefore(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "before");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    return JSValue::encode(castedThis->before(*state));
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAfter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "after");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    return JSValue::encode(castedThis->after(*state));
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionReplaceWith(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "replaceWith");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    return JSValue::encode(castedThis->replaceWith(*state));
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemove(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "remove");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    ExceptionCode ec = 0;
    impl.remove(ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionPrepend(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "prepend");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    return JSValue::encode(castedThis->prepend(*state));
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAppend(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "append");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    return JSValue::encode(castedThis->append(*state));
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelector(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "querySelector");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto selectors = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.querySelector(WTFMove(selectors), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelectorAll(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsElementCast(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "Element", "querySelectorAll");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto selectors = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), impl.querySelectorAll(WTFMove(selectors), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

void JSElement::visitChildren(JSCell* cell, SlotVisitor& visitor)
{
    auto* thisObject = jsCast<JSElement*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    thisObject->wrapped().visitJSEventListeners(visitor);
}

Element* JSElement::toWrapped(JSC::JSValue value)
{
    if (auto* wrapper = jsElementCast(value))
        return &wrapper->wrapped();
    return nullptr;
}

}
