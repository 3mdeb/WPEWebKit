/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"
#include "JSCanvasRenderingContext2D.h"

#include "CanvasGradient.h"
#include "CanvasPattern.h"
#include "ExceptionCode.h"
#include "ImageData.h"
#include "JSCanvasGradient.h"
#include "JSCanvasPattern.h"
#include "JSDOMBinding.h"
#include "JSDOMConstructor.h"
#include "JSDOMConvert.h"
#include "JSDOMPath.h"
#include "JSElement.h"
#include "JSHTMLCanvasElement.h"
#include "JSHTMLImageElement.h"
#include "JSImageData.h"
#include "JSTextMetrics.h"
#include "TextMetrics.h"
#include "URL.h"
#include <runtime/Error.h>
#include <runtime/FunctionPrototype.h>
#include <runtime/JSArray.h>
#include <runtime/JSString.h>
#include <wtf/GetPtr.h>

#if ENABLE(VIDEO)
#include "JSHTMLVideoElement.h"
#endif

using namespace JSC;

namespace WebCore {

template<typename T> Optional<T> parse(ExecState&, JSValue);
template<typename T> const char* expectedEnumerationValues();

JSString* jsStringWithCache(ExecState*, CanvasRenderingContext2D::ImageSmoothingQuality);

JSString* jsStringWithCache(ExecState* state, CanvasRenderingContext2D::ImageSmoothingQuality enumerationValue)
{
    static NeverDestroyed<const String> values[] = {
        ASCIILiteral("low"),
        ASCIILiteral("medium"),
        ASCIILiteral("high"),
    };
    static_assert(static_cast<size_t>(CanvasRenderingContext2D::ImageSmoothingQuality::Low) == 0, "CanvasRenderingContext2D::ImageSmoothingQuality::Low is not 0 as expected");
    static_assert(static_cast<size_t>(CanvasRenderingContext2D::ImageSmoothingQuality::Medium) == 1, "CanvasRenderingContext2D::ImageSmoothingQuality::Medium is not 1 as expected");
    static_assert(static_cast<size_t>(CanvasRenderingContext2D::ImageSmoothingQuality::High) == 2, "CanvasRenderingContext2D::ImageSmoothingQuality::High is not 2 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < WTF_ARRAY_LENGTH(values));
    return jsStringWithCache(state, values[static_cast<size_t>(enumerationValue)]);
}

template<> struct JSValueTraits<CanvasRenderingContext2D::ImageSmoothingQuality> {
    static JSString* arrayJSValue(ExecState* state, JSDOMGlobalObject*, CanvasRenderingContext2D::ImageSmoothingQuality value) { return jsStringWithCache(state, value); }
};

template<> Optional<CanvasRenderingContext2D::ImageSmoothingQuality> parse<CanvasRenderingContext2D::ImageSmoothingQuality>(ExecState& state, JSValue value)
{
    auto stringValue = value.toWTFString(&state);
    if (stringValue == "low")
        return CanvasRenderingContext2D::ImageSmoothingQuality::Low;
    if (stringValue == "medium")
        return CanvasRenderingContext2D::ImageSmoothingQuality::Medium;
    if (stringValue == "high")
        return CanvasRenderingContext2D::ImageSmoothingQuality::High;
    return Nullopt;
}

template<> CanvasRenderingContext2D::ImageSmoothingQuality convert<CanvasRenderingContext2D::ImageSmoothingQuality>(ExecState& state, JSValue value)
{
    auto result = parse<CanvasRenderingContext2D::ImageSmoothingQuality>(state, value);
    if (UNLIKELY(!result)) {
        throwTypeError(&state);
        return { };
    }
    return result.value();
}

template<> inline const char* expectedEnumerationValues<CanvasRenderingContext2D::ImageSmoothingQuality>()
{
    return "\"low\", \"medium\", \"high\"";
}

JSString* jsStringWithCache(ExecState*, CanvasRenderingContext2D::WindingRule);

JSString* jsStringWithCache(ExecState* state, CanvasRenderingContext2D::WindingRule enumerationValue)
{
    static NeverDestroyed<const String> values[] = {
        ASCIILiteral("nonzero"),
        ASCIILiteral("evenodd"),
    };
    static_assert(static_cast<size_t>(CanvasRenderingContext2D::WindingRule::Nonzero) == 0, "CanvasRenderingContext2D::WindingRule::Nonzero is not 0 as expected");
    static_assert(static_cast<size_t>(CanvasRenderingContext2D::WindingRule::Evenodd) == 1, "CanvasRenderingContext2D::WindingRule::Evenodd is not 1 as expected");
    ASSERT(static_cast<size_t>(enumerationValue) < WTF_ARRAY_LENGTH(values));
    return jsStringWithCache(state, values[static_cast<size_t>(enumerationValue)]);
}

template<> struct JSValueTraits<CanvasRenderingContext2D::WindingRule> {
    static JSString* arrayJSValue(ExecState* state, JSDOMGlobalObject*, CanvasRenderingContext2D::WindingRule value) { return jsStringWithCache(state, value); }
};

template<> Optional<CanvasRenderingContext2D::WindingRule> parse<CanvasRenderingContext2D::WindingRule>(ExecState& state, JSValue value)
{
    auto stringValue = value.toWTFString(&state);
    if (stringValue == "nonzero")
        return CanvasRenderingContext2D::WindingRule::Nonzero;
    if (stringValue == "evenodd")
        return CanvasRenderingContext2D::WindingRule::Evenodd;
    return Nullopt;
}

template<> CanvasRenderingContext2D::WindingRule convert<CanvasRenderingContext2D::WindingRule>(ExecState& state, JSValue value)
{
    auto result = parse<CanvasRenderingContext2D::WindingRule>(state, value);
    if (UNLIKELY(!result)) {
        throwTypeError(&state);
        return { };
    }
    return result.value();
}

template<> inline const char* expectedEnumerationValues<CanvasRenderingContext2D::WindingRule>()
{
    return "\"nonzero\", \"evenodd\"";
}

// Functions

JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSave(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRestore(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCommit(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionScale(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRotate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionTranslate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionTransform(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetTransform(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateLinearGradient(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateRadialGradient(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineDash(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionGetLineDash(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClearRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFillRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionBeginPath(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFill(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStroke(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClip(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionMeasureText(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetAlpha(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetCompositeOperation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineWidth(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineCap(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineJoin(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetMiterLimit(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClearShadow(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFillText(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStrokeText(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetFillColor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStrokeRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImageFromRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetShadow(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionPutImageData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreatePattern(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateImageData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionGetImageData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionWebkitGetImageDataHD(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawSystemFocusRing(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClosePath(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionMoveTo(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionLineTo(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionQuadraticCurveTo(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionBezierCurveTo(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionArcTo(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRect(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionArc(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionEllipse(JSC::ExecState*);

// Attributes

JSC::EncodedJSValue jsCanvasRenderingContext2DGlobalAlpha(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DGlobalAlpha(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DGlobalCompositeOperation(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DGlobalCompositeOperation(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DLineWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DLineWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DLineCap(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DLineCap(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DLineJoin(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DLineJoin(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DMiterLimit(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DMiterLimit(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DShadowOffsetX(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DShadowOffsetX(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DShadowOffsetY(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DShadowOffsetY(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DShadowBlur(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DShadowBlur(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DShadowColor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DShadowColor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DLineDashOffset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DLineDashOffset(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DWebkitLineDash(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DWebkitLineDash(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DWebkitLineDashOffset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DWebkitLineDashOffset(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DFont(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DFont(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DTextAlign(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DTextAlign(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DTextBaseline(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DTextBaseline(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DDirection(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DDirection(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DStrokeStyle(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DStrokeStyle(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DFillStyle(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DFillStyle(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DWebkitBackingStorePixelRatio(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsCanvasRenderingContext2DImageSmoothingEnabled(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DImageSmoothingEnabled(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DWebkitImageSmoothingEnabled(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DWebkitImageSmoothingEnabled(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DImageSmoothingQuality(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DImageSmoothingQuality(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
JSC::EncodedJSValue jsCanvasRenderingContext2DConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSCanvasRenderingContext2DConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);

class JSCanvasRenderingContext2DPrototype : public JSC::JSNonFinalObject {
public:
    typedef JSC::JSNonFinalObject Base;
    static JSCanvasRenderingContext2DPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSCanvasRenderingContext2DPrototype* ptr = new (NotNull, JSC::allocateCell<JSCanvasRenderingContext2DPrototype>(vm.heap)) JSCanvasRenderingContext2DPrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSCanvasRenderingContext2DPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};

typedef JSDOMConstructorNotConstructable<JSCanvasRenderingContext2D> JSCanvasRenderingContext2DConstructor;

template<> JSValue JSCanvasRenderingContext2DConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
{
    UNUSED_PARAM(vm);
    return globalObject.functionPrototype();
}

template<> void JSCanvasRenderingContext2DConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
{
    putDirect(vm, vm.propertyNames->prototype, JSCanvasRenderingContext2D::prototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("CanvasRenderingContext2D"))), ReadOnly | DontEnum);
    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
}

template<> const ClassInfo JSCanvasRenderingContext2DConstructor::s_info = { "CanvasRenderingContext2D", &Base::s_info, 0, CREATE_METHOD_TABLE(JSCanvasRenderingContext2DConstructor) };

/* Hash table for prototype */

static const HashTableValue JSCanvasRenderingContext2DPrototypeTableValues[] =
{
    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DConstructor) } },
    { "globalAlpha", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DGlobalAlpha), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DGlobalAlpha) } },
    { "globalCompositeOperation", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DGlobalCompositeOperation), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DGlobalCompositeOperation) } },
    { "lineWidth", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DLineWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DLineWidth) } },
    { "lineCap", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DLineCap), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DLineCap) } },
    { "lineJoin", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DLineJoin), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DLineJoin) } },
    { "miterLimit", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DMiterLimit), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DMiterLimit) } },
    { "shadowOffsetX", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DShadowOffsetX), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DShadowOffsetX) } },
    { "shadowOffsetY", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DShadowOffsetY), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DShadowOffsetY) } },
    { "shadowBlur", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DShadowBlur), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DShadowBlur) } },
    { "shadowColor", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DShadowColor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DShadowColor) } },
    { "lineDashOffset", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DLineDashOffset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DLineDashOffset) } },
    { "webkitLineDash", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DWebkitLineDash), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DWebkitLineDash) } },
    { "webkitLineDashOffset", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DWebkitLineDashOffset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DWebkitLineDashOffset) } },
    { "font", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DFont), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DFont) } },
    { "textAlign", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DTextAlign), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DTextAlign) } },
    { "textBaseline", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DTextBaseline), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DTextBaseline) } },
    { "direction", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DDirection), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DDirection) } },
    { "strokeStyle", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DStrokeStyle), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DStrokeStyle) } },
    { "fillStyle", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DFillStyle), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DFillStyle) } },
    { "webkitBackingStorePixelRatio", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DWebkitBackingStorePixelRatio), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "imageSmoothingEnabled", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DImageSmoothingEnabled), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DImageSmoothingEnabled) } },
    { "webkitImageSmoothingEnabled", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DWebkitImageSmoothingEnabled), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DWebkitImageSmoothingEnabled) } },
    { "imageSmoothingQuality", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsCanvasRenderingContext2DImageSmoothingQuality), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSCanvasRenderingContext2DImageSmoothingQuality) } },
    { "save", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSave), (intptr_t) (0) } },
    { "restore", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionRestore), (intptr_t) (0) } },
    { "commit", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionCommit), (intptr_t) (0) } },
    { "scale", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionScale), (intptr_t) (2) } },
    { "rotate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionRotate), (intptr_t) (1) } },
    { "translate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionTranslate), (intptr_t) (2) } },
    { "transform", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionTransform), (intptr_t) (6) } },
    { "setTransform", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetTransform), (intptr_t) (6) } },
    { "createLinearGradient", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionCreateLinearGradient), (intptr_t) (4) } },
    { "createRadialGradient", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionCreateRadialGradient), (intptr_t) (6) } },
    { "setLineDash", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetLineDash), (intptr_t) (1) } },
    { "getLineDash", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionGetLineDash), (intptr_t) (0) } },
    { "clearRect", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionClearRect), (intptr_t) (4) } },
    { "fillRect", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionFillRect), (intptr_t) (4) } },
    { "beginPath", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionBeginPath), (intptr_t) (0) } },
    { "fill", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionFill), (intptr_t) (0) } },
    { "stroke", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionStroke), (intptr_t) (0) } },
    { "clip", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionClip), (intptr_t) (0) } },
    { "isPointInPath", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath), (intptr_t) (2) } },
    { "isPointInStroke", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke), (intptr_t) (2) } },
    { "measureText", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionMeasureText), (intptr_t) (1) } },
    { "setAlpha", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetAlpha), (intptr_t) (0) } },
    { "setCompositeOperation", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetCompositeOperation), (intptr_t) (0) } },
    { "setLineWidth", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetLineWidth), (intptr_t) (0) } },
    { "setLineCap", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetLineCap), (intptr_t) (0) } },
    { "setLineJoin", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetLineJoin), (intptr_t) (0) } },
    { "setMiterLimit", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetMiterLimit), (intptr_t) (0) } },
    { "clearShadow", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionClearShadow), (intptr_t) (0) } },
    { "fillText", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionFillText), (intptr_t) (3) } },
    { "strokeText", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionStrokeText), (intptr_t) (3) } },
    { "setStrokeColor", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor), (intptr_t) (1) } },
    { "setFillColor", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetFillColor), (intptr_t) (1) } },
    { "strokeRect", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionStrokeRect), (intptr_t) (4) } },
    { "drawImage", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionDrawImage), (intptr_t) (3) } },
    { "drawImageFromRect", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionDrawImageFromRect), (intptr_t) (1) } },
    { "setShadow", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetShadow), (intptr_t) (3) } },
    { "putImageData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionPutImageData), (intptr_t) (3) } },
    { "webkitPutImageDataHD", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD), (intptr_t) (3) } },
    { "createPattern", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionCreatePattern), (intptr_t) (2) } },
    { "createImageData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionCreateImageData), (intptr_t) (1) } },
    { "getImageData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionGetImageData), (intptr_t) (4) } },
    { "webkitGetImageDataHD", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionWebkitGetImageDataHD), (intptr_t) (4) } },
    { "drawFocusIfNeeded", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded), (intptr_t) (1) } },
    { "drawSystemFocusRing", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionDrawSystemFocusRing), (intptr_t) (1) } },
    { "closePath", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionClosePath), (intptr_t) (0) } },
    { "moveTo", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionMoveTo), (intptr_t) (2) } },
    { "lineTo", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionLineTo), (intptr_t) (2) } },
    { "quadraticCurveTo", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionQuadraticCurveTo), (intptr_t) (4) } },
    { "bezierCurveTo", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionBezierCurveTo), (intptr_t) (6) } },
    { "arcTo", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionArcTo), (intptr_t) (5) } },
    { "rect", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionRect), (intptr_t) (4) } },
    { "arc", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionArc), (intptr_t) (5) } },
    { "ellipse", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionEllipse), (intptr_t) (7) } },
};

const ClassInfo JSCanvasRenderingContext2DPrototype::s_info = { "CanvasRenderingContext2DPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSCanvasRenderingContext2DPrototype) };

void JSCanvasRenderingContext2DPrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSCanvasRenderingContext2DPrototypeTableValues, *this);
}

const ClassInfo JSCanvasRenderingContext2D::s_info = { "CanvasRenderingContext2D", &Base::s_info, 0, CREATE_METHOD_TABLE(JSCanvasRenderingContext2D) };

JSCanvasRenderingContext2D::JSCanvasRenderingContext2D(Structure* structure, JSDOMGlobalObject& globalObject, Ref<CanvasRenderingContext2D>&& impl)
    : JSCanvasRenderingContext(structure, globalObject, WTFMove(impl))
{
}

JSObject* JSCanvasRenderingContext2D::createPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return JSCanvasRenderingContext2DPrototype::create(vm, globalObject, JSCanvasRenderingContext2DPrototype::createStructure(vm, globalObject, JSCanvasRenderingContext::prototype(vm, globalObject)));
}

JSObject* JSCanvasRenderingContext2D::prototype(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSCanvasRenderingContext2D>(vm, globalObject);
}

EncodedJSValue jsCanvasRenderingContext2DGlobalAlpha(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "globalAlpha");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.globalAlpha());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DGlobalCompositeOperation(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "globalCompositeOperation");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.globalCompositeOperation());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DLineWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "lineWidth");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.lineWidth());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DLineCap(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "lineCap");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.lineCap());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DLineJoin(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "lineJoin");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.lineJoin());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DMiterLimit(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "miterLimit");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.miterLimit());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DShadowOffsetX(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "shadowOffsetX");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.shadowOffsetX());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DShadowOffsetY(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "shadowOffsetY");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.shadowOffsetY());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DShadowBlur(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "shadowBlur");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.shadowBlur());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DShadowColor(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "shadowColor");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.shadowColor());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DLineDashOffset(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "lineDashOffset");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.lineDashOffset());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DWebkitLineDash(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "webkitLineDash");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsArray(state, castedThis->globalObject(), impl.webkitLineDash());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DWebkitLineDashOffset(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "webkitLineDashOffset");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.lineDashOffset());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DFont(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "font");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.font());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DTextAlign(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "textAlign");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.textAlign());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DTextBaseline(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "textBaseline");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.textBaseline());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DDirection(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "direction");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.direction());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DStrokeStyle(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "strokeStyle");
    }
    return JSValue::encode(castedThis->strokeStyle(*state));
}


EncodedJSValue jsCanvasRenderingContext2DFillStyle(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "fillStyle");
    }
    return JSValue::encode(castedThis->fillStyle(*state));
}


EncodedJSValue jsCanvasRenderingContext2DWebkitBackingStorePixelRatio(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "webkitBackingStorePixelRatio");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.webkitBackingStorePixelRatio());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DImageSmoothingEnabled(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "imageSmoothingEnabled");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsBoolean(impl.imageSmoothingEnabled());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DWebkitImageSmoothingEnabled(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "webkitImageSmoothingEnabled");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsBoolean(impl.imageSmoothingEnabled());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DImageSmoothingQuality(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "CanvasRenderingContext2D", "imageSmoothingQuality");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsStringWithCache(state, impl.imageSmoothingQuality());
    return JSValue::encode(result);
}


EncodedJSValue jsCanvasRenderingContext2DConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    JSCanvasRenderingContext2DPrototype* domObject = jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject))
        return throwVMTypeError(state);
    return JSValue::encode(JSCanvasRenderingContext2D::getConstructor(state->vm(), domObject->globalObject()));
}

bool setJSCanvasRenderingContext2DConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    JSCanvasRenderingContext2DPrototype* domObject = jsDynamicCast<JSCanvasRenderingContext2DPrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject)) {
        throwVMTypeError(state);
        return false;
    }
    // Shadowing a built-in constructor
    return domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
}

bool setJSCanvasRenderingContext2DGlobalAlpha(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "globalAlpha");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = convert<float>(*state, value, ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setGlobalAlpha(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DGlobalCompositeOperation(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "globalCompositeOperation");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setGlobalCompositeOperation(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DLineWidth(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "lineWidth");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = convert<float>(*state, value, ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setLineWidth(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DLineCap(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "lineCap");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setLineCap(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DLineJoin(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "lineJoin");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setLineJoin(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DMiterLimit(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "miterLimit");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = convert<float>(*state, value, ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setMiterLimit(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DShadowOffsetX(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "shadowOffsetX");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = convert<float>(*state, value, ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setShadowOffsetX(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DShadowOffsetY(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "shadowOffsetY");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = convert<float>(*state, value, ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setShadowOffsetY(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DShadowBlur(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "shadowBlur");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = convert<float>(*state, value, ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setShadowBlur(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DShadowColor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "shadowColor");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setShadowColor(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DLineDashOffset(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "lineDashOffset");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = convert<float>(*state, value, ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setLineDashOffset(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DWebkitLineDash(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "webkitLineDash");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = toNativeArray<float>(*state, value);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setWebkitLineDash(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DWebkitLineDashOffset(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "webkitLineDashOffset");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = convert<float>(*state, value, ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setLineDashOffset(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DFont(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "font");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setFont(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DTextAlign(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "textAlign");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setTextAlign(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DTextBaseline(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "textBaseline");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setTextBaseline(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DDirection(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "direction");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setDirection(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DStrokeStyle(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "strokeStyle");
    }
    castedThis->setStrokeStyle(*state, value);
    return true;
}


bool setJSCanvasRenderingContext2DFillStyle(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "fillStyle");
    }
    castedThis->setFillStyle(*state, value);
    return true;
}


bool setJSCanvasRenderingContext2DImageSmoothingEnabled(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "imageSmoothingEnabled");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setImageSmoothingEnabled(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DWebkitImageSmoothingEnabled(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "webkitImageSmoothingEnabled");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = value.toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return false;
    impl.setImageSmoothingEnabled(WTFMove(nativeValue));
    return true;
}


bool setJSCanvasRenderingContext2DImageSmoothingQuality(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    UNUSED_PARAM(thisValue);
    JSCanvasRenderingContext2D* castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(JSValue::decode(thisValue));
    if (UNLIKELY(!castedThis)) {
        return throwSetterTypeError(*state, "CanvasRenderingContext2D", "imageSmoothingQuality");
    }
    auto& impl = castedThis->wrapped();
    auto nativeValue = parse<CanvasRenderingContext2D::ImageSmoothingQuality>(*state, value);
    if (UNLIKELY(state->hadException()))
        return false;
    if (UNLIKELY(!nativeValue))
        return false;
    impl.setImageSmoothingQuality(nativeValue.value());
    return true;
}


JSValue JSCanvasRenderingContext2D::getConstructor(VM& vm, const JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSCanvasRenderingContext2DConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSave(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "save");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    impl.save();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRestore(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "restore");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    impl.restore();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCommit(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "commit");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    impl.commit();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionScale(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "scale");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto sx = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sy = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.scale(WTFMove(sx), WTFMove(sy));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRotate(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "rotate");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto angle = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.rotate(WTFMove(angle));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionTranslate(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "translate");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto tx = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto ty = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.translate(WTFMove(tx), WTFMove(ty));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionTransform(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "transform");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto m11 = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto m12 = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto m21 = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto m22 = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dx = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dy = convert<float>(*state, state->argument(5), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.transform(WTFMove(m11), WTFMove(m12), WTFMove(m21), WTFMove(m22), WTFMove(dx), WTFMove(dy));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetTransform(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setTransform");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto m11 = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto m12 = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto m21 = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto m22 = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dx = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dy = convert<float>(*state, state->argument(5), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setTransform(WTFMove(m11), WTFMove(m12), WTFMove(m21), WTFMove(m22), WTFMove(dx), WTFMove(dy));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateLinearGradient(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "createLinearGradient");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto x0 = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y0 = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x1 = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y1 = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.createLinearGradient(WTFMove(x0), WTFMove(y0), WTFMove(x1), WTFMove(y1), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateRadialGradient(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "createRadialGradient");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto x0 = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y0 = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto r0 = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x1 = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y1 = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto r1 = convert<float>(*state, state->argument(5), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.createRadialGradient(WTFMove(x0), WTFMove(y0), WTFMove(r0), WTFMove(x1), WTFMove(y1), WTFMove(r1), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineDash(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setLineDash");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto dash = toNativeArray<float>(*state, state->argument(0));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setLineDash(WTFMove(dash));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionGetLineDash(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "getLineDash");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    JSValue result = jsArray(state, castedThis->globalObject(), impl.getLineDash());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClearRect(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "clearRect");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto x = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.clearRect(WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFillRect(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "fillRect");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto x = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.fillRect(WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionBeginPath(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "beginPath");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    impl.beginPath();
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionFill1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "fill");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto path = JSDOMPath::toWrapped(state->argument(0));
    if (UNLIKELY(!path))
        return throwArgumentTypeError(*state, 0, "path", "CanvasRenderingContext2D", "fill", "DOMPath");
    auto windingValue = state->argument(1);
    CanvasRenderingContext2D::WindingRule winding;
    if (windingValue.isUndefined()) {
        winding = CanvasRenderingContext2D::WindingRule::Nonzero;
    } else {
        auto optionalValue = parse<CanvasRenderingContext2D::WindingRule>(*state, windingValue);
        if (UNLIKELY(state->hadException()))
            return JSValue::encode(jsUndefined());
        if (UNLIKELY(!optionalValue))
            return throwArgumentMustBeEnumError(*state, 1, "winding", "CanvasRenderingContext2D", "fill", expectedEnumerationValues<CanvasRenderingContext2D::WindingRule>());
        winding = optionalValue.value();
    }
    impl.fill(*path, winding);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionStroke1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "stroke");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto path = JSDOMPath::toWrapped(state->argument(0));
    if (UNLIKELY(!path))
        return throwArgumentTypeError(*state, 0, "path", "CanvasRenderingContext2D", "stroke", "DOMPath");
    impl.stroke(*path);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionClip1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "clip");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto path = JSDOMPath::toWrapped(state->argument(0));
    if (UNLIKELY(!path))
        return throwArgumentTypeError(*state, 0, "path", "CanvasRenderingContext2D", "clip", "DOMPath");
    auto windingValue = state->argument(1);
    CanvasRenderingContext2D::WindingRule winding;
    if (windingValue.isUndefined()) {
        winding = CanvasRenderingContext2D::WindingRule::Nonzero;
    } else {
        auto optionalValue = parse<CanvasRenderingContext2D::WindingRule>(*state, windingValue);
        if (UNLIKELY(state->hadException()))
            return JSValue::encode(jsUndefined());
        if (UNLIKELY(!optionalValue))
            return throwArgumentMustBeEnumError(*state, 1, "winding", "CanvasRenderingContext2D", "clip", expectedEnumerationValues<CanvasRenderingContext2D::WindingRule>());
        winding = optionalValue.value();
    }
    impl.clip(*path, winding);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionFill2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "fill");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    auto windingValue = state->argument(0);
    CanvasRenderingContext2D::WindingRule winding;
    if (windingValue.isUndefined()) {
        winding = CanvasRenderingContext2D::WindingRule::Nonzero;
    } else {
        auto optionalValue = parse<CanvasRenderingContext2D::WindingRule>(*state, windingValue);
        if (UNLIKELY(state->hadException()))
            return JSValue::encode(jsUndefined());
        if (UNLIKELY(!optionalValue))
            return throwArgumentMustBeEnumError(*state, 0, "winding", "CanvasRenderingContext2D", "fill", expectedEnumerationValues<CanvasRenderingContext2D::WindingRule>());
        winding = optionalValue.value();
    }
    impl.fill(winding);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFill(ExecState* state)
{
    size_t argsCount = std::min<size_t>(2, state->argumentCount());
    if (argsCount == 0) {
        return jsCanvasRenderingContext2DPrototypeFunctionFill2(state);
    }
    if (argsCount == 1) {
        JSValue distinguishingArg = state->uncheckedArgument(0);
        if (distinguishingArg.isUndefined())
            return jsCanvasRenderingContext2DPrototypeFunctionFill2(state);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSDOMPath::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionFill1(state);
        return jsCanvasRenderingContext2DPrototypeFunctionFill2(state);
    }
    if (argsCount == 2) {
        return jsCanvasRenderingContext2DPrototypeFunctionFill1(state);
    }
    return throwVMTypeError(state);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionStroke2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "stroke");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    impl.stroke();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStroke(ExecState* state)
{
    size_t argsCount = std::min<size_t>(1, state->argumentCount());
    if (argsCount == 0) {
        return jsCanvasRenderingContext2DPrototypeFunctionStroke2(state);
    }
    if (argsCount == 1) {
        return jsCanvasRenderingContext2DPrototypeFunctionStroke1(state);
    }
    return throwVMTypeError(state);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionClip2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "clip");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    auto windingValue = state->argument(0);
    CanvasRenderingContext2D::WindingRule winding;
    if (windingValue.isUndefined()) {
        winding = CanvasRenderingContext2D::WindingRule::Nonzero;
    } else {
        auto optionalValue = parse<CanvasRenderingContext2D::WindingRule>(*state, windingValue);
        if (UNLIKELY(state->hadException()))
            return JSValue::encode(jsUndefined());
        if (UNLIKELY(!optionalValue))
            return throwArgumentMustBeEnumError(*state, 0, "winding", "CanvasRenderingContext2D", "clip", expectedEnumerationValues<CanvasRenderingContext2D::WindingRule>());
        winding = optionalValue.value();
    }
    impl.clip(winding);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClip(ExecState* state)
{
    size_t argsCount = std::min<size_t>(2, state->argumentCount());
    if (argsCount == 0) {
        return jsCanvasRenderingContext2DPrototypeFunctionClip2(state);
    }
    if (argsCount == 1) {
        JSValue distinguishingArg = state->uncheckedArgument(0);
        if (distinguishingArg.isUndefined())
            return jsCanvasRenderingContext2DPrototypeFunctionClip2(state);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSDOMPath::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionClip1(state);
        return jsCanvasRenderingContext2DPrototypeFunctionClip2(state);
    }
    if (argsCount == 2) {
        return jsCanvasRenderingContext2DPrototypeFunctionClip1(state);
    }
    return throwVMTypeError(state);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "isPointInPath");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto path = JSDOMPath::toWrapped(state->argument(0));
    if (UNLIKELY(!path))
        return throwArgumentTypeError(*state, 0, "path", "CanvasRenderingContext2D", "isPointInPath", "DOMPath");
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto windingValue = state->argument(3);
    CanvasRenderingContext2D::WindingRule winding;
    if (windingValue.isUndefined()) {
        winding = CanvasRenderingContext2D::WindingRule::Nonzero;
    } else {
        auto optionalValue = parse<CanvasRenderingContext2D::WindingRule>(*state, windingValue);
        if (UNLIKELY(state->hadException()))
            return JSValue::encode(jsUndefined());
        if (UNLIKELY(!optionalValue))
            return throwArgumentMustBeEnumError(*state, 3, "winding", "CanvasRenderingContext2D", "isPointInPath", expectedEnumerationValues<CanvasRenderingContext2D::WindingRule>());
        winding = optionalValue.value();
    }
    JSValue result = jsBoolean(impl.isPointInPath(*path, WTFMove(x), WTFMove(y), winding));
    return JSValue::encode(result);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "isPointInStroke");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto path = JSDOMPath::toWrapped(state->argument(0));
    if (UNLIKELY(!path))
        return throwArgumentTypeError(*state, 0, "path", "CanvasRenderingContext2D", "isPointInStroke", "DOMPath");
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsBoolean(impl.isPointInStroke(*path, WTFMove(x), WTFMove(y)));
    return JSValue::encode(result);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "isPointInPath");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto x = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto windingValue = state->argument(2);
    CanvasRenderingContext2D::WindingRule winding;
    if (windingValue.isUndefined()) {
        winding = CanvasRenderingContext2D::WindingRule::Nonzero;
    } else {
        auto optionalValue = parse<CanvasRenderingContext2D::WindingRule>(*state, windingValue);
        if (UNLIKELY(state->hadException()))
            return JSValue::encode(jsUndefined());
        if (UNLIKELY(!optionalValue))
            return throwArgumentMustBeEnumError(*state, 2, "winding", "CanvasRenderingContext2D", "isPointInPath", expectedEnumerationValues<CanvasRenderingContext2D::WindingRule>());
        winding = optionalValue.value();
    }
    JSValue result = jsBoolean(impl.isPointInPath(WTFMove(x), WTFMove(y), winding));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath(ExecState* state)
{
    size_t argsCount = std::min<size_t>(4, state->argumentCount());
    if (argsCount == 2) {
        return jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath2(state);
    }
    if (argsCount == 3) {
        JSValue distinguishingArg = state->uncheckedArgument(0);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSDOMPath::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath1(state);
        if (distinguishingArg.isNumber())
            return jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath2(state);
        return jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath2(state);
    }
    if (argsCount == 4) {
        return jsCanvasRenderingContext2DPrototypeFunctionIsPointInPath1(state);
    }
    return argsCount < 2 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "isPointInStroke");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto x = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsBoolean(impl.isPointInStroke(WTFMove(x), WTFMove(y)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke(ExecState* state)
{
    size_t argsCount = std::min<size_t>(3, state->argumentCount());
    if (argsCount == 2) {
        return jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke2(state);
    }
    if (argsCount == 3) {
        return jsCanvasRenderingContext2DPrototypeFunctionIsPointInStroke1(state);
    }
    return argsCount < 2 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionMeasureText(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "measureText");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto text = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.measureText(WTFMove(text)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetAlpha(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setAlpha");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    auto alpha = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setAlpha(WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetCompositeOperation(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setCompositeOperation");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    auto compositeOperation = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setCompositeOperation(WTFMove(compositeOperation));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineWidth(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setLineWidth");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    auto width = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setLineWidth(WTFMove(width));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineCap(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setLineCap");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    auto cap = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setLineCap(WTFMove(cap));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineJoin(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setLineJoin");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    auto join = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setLineJoin(WTFMove(join));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetMiterLimit(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setMiterLimit");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    auto limit = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setMiterLimit(WTFMove(limit));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClearShadow(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "clearShadow");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    impl.clearShadow();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFillText(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "fillText");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto text = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto maxWidth = state->argument(3).isUndefined() ? Optional<float>() : convert<float>(*state, state->uncheckedArgument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.fillText(WTFMove(text), WTFMove(x), WTFMove(y), WTFMove(maxWidth));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStrokeText(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "strokeText");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto text = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto maxWidth = state->argument(3).isUndefined() ? Optional<float>() : convert<float>(*state, state->uncheckedArgument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.strokeText(WTFMove(text), WTFMove(x), WTFMove(y), WTFMove(maxWidth));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setStrokeColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto color = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto alpha = state->argument(1).isUndefined() ? Optional<float>() : convert<float>(*state, state->uncheckedArgument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setStrokeColor(WTFMove(color), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setStrokeColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto grayLevel = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto alpha = state->argument(1).isUndefined() ? 1 : convert<float>(*state, state->uncheckedArgument(1), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setStrokeColor(WTFMove(grayLevel), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor3(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setStrokeColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto r = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto g = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto b = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto a = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setStrokeColor(WTFMove(r), WTFMove(g), WTFMove(b), WTFMove(a));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor4(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setStrokeColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto c = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto m = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto k = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto a = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setStrokeColor(WTFMove(c), WTFMove(m), WTFMove(y), WTFMove(k), WTFMove(a));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor(ExecState* state)
{
    size_t argsCount = std::min<size_t>(5, state->argumentCount());
    if (argsCount == 1) {
        JSValue distinguishingArg = state->uncheckedArgument(0);
        if (distinguishingArg.isNumber())
            return jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor2(state);
        return jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor1(state);
    }
    if (argsCount == 2) {
        JSValue distinguishingArg = state->uncheckedArgument(0);
        if (distinguishingArg.isNumber())
            return jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor2(state);
        return jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor1(state);
    }
    if (argsCount == 4) {
        return jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor3(state);
    }
    if (argsCount == 5) {
        return jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor4(state);
    }
    return argsCount < 1 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetFillColor1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setFillColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto color = state->argument(0).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto alpha = state->argument(1).isUndefined() ? Optional<float>() : convert<float>(*state, state->uncheckedArgument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setFillColor(WTFMove(color), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetFillColor2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setFillColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto grayLevel = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto alpha = state->argument(1).isUndefined() ? 1 : convert<float>(*state, state->uncheckedArgument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setFillColor(WTFMove(grayLevel), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetFillColor3(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setFillColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto r = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto g = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto b = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto a = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setFillColor(WTFMove(r), WTFMove(g), WTFMove(b), WTFMove(a));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetFillColor4(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setFillColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto c = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto m = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto k = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto a = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setFillColor(WTFMove(c), WTFMove(m), WTFMove(y), WTFMove(k), WTFMove(a));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetFillColor(ExecState* state)
{
    size_t argsCount = std::min<size_t>(5, state->argumentCount());
    if (argsCount == 1) {
        JSValue distinguishingArg = state->uncheckedArgument(0);
        if (distinguishingArg.isNumber())
            return jsCanvasRenderingContext2DPrototypeFunctionSetFillColor2(state);
        return jsCanvasRenderingContext2DPrototypeFunctionSetFillColor1(state);
    }
    if (argsCount == 2) {
        JSValue distinguishingArg = state->uncheckedArgument(0);
        if (distinguishingArg.isNumber())
            return jsCanvasRenderingContext2DPrototypeFunctionSetFillColor2(state);
        return jsCanvasRenderingContext2DPrototypeFunctionSetFillColor1(state);
    }
    if (argsCount == 4) {
        return jsCanvasRenderingContext2DPrototypeFunctionSetFillColor3(state);
    }
    if (argsCount == 5) {
        return jsCanvasRenderingContext2DPrototypeFunctionSetFillColor4(state);
    }
    return argsCount < 1 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStrokeRect(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "strokeRect");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto x = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.strokeRect(WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawImage1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto image = JSHTMLImageElement::toWrapped(state->argument(0));
    if (UNLIKELY(!image))
        return throwArgumentTypeError(*state, 0, "image", "CanvasRenderingContext2D", "drawImage", "HTMLImageElement");
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(*image, WTFMove(x), WTFMove(y), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawImage2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto image = JSHTMLImageElement::toWrapped(state->argument(0));
    if (UNLIKELY(!image))
        return throwArgumentTypeError(*state, 0, "image", "CanvasRenderingContext2D", "drawImage", "HTMLImageElement");
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(*image, WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawImage3(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 9))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto image = JSHTMLImageElement::toWrapped(state->argument(0));
    if (UNLIKELY(!image))
        return throwArgumentTypeError(*state, 0, "image", "CanvasRenderingContext2D", "drawImage", "HTMLImageElement");
    auto sx = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sy = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sw = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sh = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dx = convert<float>(*state, state->argument(5), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dy = convert<float>(*state, state->argument(6), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dw = convert<float>(*state, state->argument(7), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dh = convert<float>(*state, state->argument(8), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(*image, WTFMove(sx), WTFMove(sy), WTFMove(sw), WTFMove(sh), WTFMove(dx), WTFMove(dy), WTFMove(dw), WTFMove(dh), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawImage4(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto canvas = JSHTMLCanvasElement::toWrapped(state->argument(0));
    if (UNLIKELY(!canvas))
        return throwArgumentTypeError(*state, 0, "canvas", "CanvasRenderingContext2D", "drawImage", "HTMLCanvasElement");
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(*canvas, WTFMove(x), WTFMove(y), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawImage5(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto canvas = JSHTMLCanvasElement::toWrapped(state->argument(0));
    if (UNLIKELY(!canvas))
        return throwArgumentTypeError(*state, 0, "canvas", "CanvasRenderingContext2D", "drawImage", "HTMLCanvasElement");
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(*canvas, WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawImage6(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 9))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto canvas = JSHTMLCanvasElement::toWrapped(state->argument(0));
    if (UNLIKELY(!canvas))
        return throwArgumentTypeError(*state, 0, "canvas", "CanvasRenderingContext2D", "drawImage", "HTMLCanvasElement");
    auto sx = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sy = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sw = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sh = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dx = convert<float>(*state, state->argument(5), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dy = convert<float>(*state, state->argument(6), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dw = convert<float>(*state, state->argument(7), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dh = convert<float>(*state, state->argument(8), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(*canvas, WTFMove(sx), WTFMove(sy), WTFMove(sw), WTFMove(sh), WTFMove(dx), WTFMove(dy), WTFMove(dw), WTFMove(dh), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

#if ENABLE(VIDEO)
static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawImage7(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto video = JSHTMLVideoElement::toWrapped(state->argument(0));
    if (UNLIKELY(!video))
        return throwArgumentTypeError(*state, 0, "video", "CanvasRenderingContext2D", "drawImage", "HTMLVideoElement");
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(*video, WTFMove(x), WTFMove(y), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

#endif

#if ENABLE(VIDEO)
static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawImage8(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto video = JSHTMLVideoElement::toWrapped(state->argument(0));
    if (UNLIKELY(!video))
        return throwArgumentTypeError(*state, 0, "video", "CanvasRenderingContext2D", "drawImage", "HTMLVideoElement");
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(*video, WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

#endif

#if ENABLE(VIDEO)
static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawImage9(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawImage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 9))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto video = JSHTMLVideoElement::toWrapped(state->argument(0));
    if (UNLIKELY(!video))
        return throwArgumentTypeError(*state, 0, "video", "CanvasRenderingContext2D", "drawImage", "HTMLVideoElement");
    auto sx = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sy = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sw = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sh = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dx = convert<float>(*state, state->argument(5), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dy = convert<float>(*state, state->argument(6), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dw = convert<float>(*state, state->argument(7), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dh = convert<float>(*state, state->argument(8), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImage(*video, WTFMove(sx), WTFMove(sy), WTFMove(sw), WTFMove(sh), WTFMove(dx), WTFMove(dy), WTFMove(dw), WTFMove(dh), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

#endif

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage(ExecState* state)
{
    size_t argsCount = std::min<size_t>(9, state->argumentCount());
    if (argsCount == 3) {
        JSValue distinguishingArg = state->uncheckedArgument(0);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLImageElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionDrawImage1(state);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLCanvasElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionDrawImage4(state);
#if ENABLE(VIDEO)
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLVideoElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionDrawImage7(state);
#endif
    }
    if (argsCount == 5) {
        JSValue distinguishingArg = state->uncheckedArgument(0);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLImageElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionDrawImage2(state);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLCanvasElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionDrawImage5(state);
#if ENABLE(VIDEO)
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLVideoElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionDrawImage8(state);
#endif
    }
    if (argsCount == 9) {
        JSValue distinguishingArg = state->uncheckedArgument(0);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLImageElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionDrawImage3(state);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLCanvasElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionDrawImage6(state);
#if ENABLE(VIDEO)
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLVideoElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionDrawImage9(state);
#endif
    }
    return argsCount < 3 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImageFromRect(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawImageFromRect");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto image = JSHTMLImageElement::toWrapped(state->argument(0));
    if (UNLIKELY(!image))
        return throwArgumentTypeError(*state, 0, "image", "CanvasRenderingContext2D", "drawImageFromRect", "HTMLImageElement");
    auto sx = state->argument(1).isUndefined() ? 0 : convert<float>(*state, state->uncheckedArgument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sy = state->argument(2).isUndefined() ? 0 : convert<float>(*state, state->uncheckedArgument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sw = state->argument(3).isUndefined() ? 0 : convert<float>(*state, state->uncheckedArgument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sh = state->argument(4).isUndefined() ? 0 : convert<float>(*state, state->uncheckedArgument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dx = state->argument(5).isUndefined() ? 0 : convert<float>(*state, state->uncheckedArgument(5), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dy = state->argument(6).isUndefined() ? 0 : convert<float>(*state, state->uncheckedArgument(6), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dw = state->argument(7).isUndefined() ? 0 : convert<float>(*state, state->uncheckedArgument(7), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dh = state->argument(8).isUndefined() ? 0 : convert<float>(*state, state->uncheckedArgument(8), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto compositeOperation = state->argument(9).isUndefined() ? emptyString() : state->uncheckedArgument(9).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawImageFromRect(*image, WTFMove(sx), WTFMove(sy), WTFMove(sw), WTFMove(sh), WTFMove(dx), WTFMove(dy), WTFMove(dw), WTFMove(dh), WTFMove(compositeOperation));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetShadow1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setShadow");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto width = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto blur = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto color = state->argument(3).isUndefined() ? String() : state->uncheckedArgument(3).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto alpha = state->argument(4).isUndefined() ? Optional<float>() : convert<float>(*state, state->uncheckedArgument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setShadow(WTFMove(width), WTFMove(height), WTFMove(blur), WTFMove(color), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetShadow2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setShadow");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto width = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto blur = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto grayLevel = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto alpha = state->argument(4).isUndefined() ? 1 : convert<float>(*state, state->uncheckedArgument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setShadow(WTFMove(width), WTFMove(height), WTFMove(blur), WTFMove(grayLevel), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetShadow3(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setShadow");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto width = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto blur = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto r = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto g = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto b = convert<float>(*state, state->argument(5), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto a = convert<float>(*state, state->argument(6), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setShadow(WTFMove(width), WTFMove(height), WTFMove(blur), WTFMove(r), WTFMove(g), WTFMove(b), WTFMove(a));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionSetShadow4(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "setShadow");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto width = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto blur = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto c = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto m = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(5), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto k = convert<float>(*state, state->argument(6), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto a = convert<float>(*state, state->argument(7), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.setShadow(WTFMove(width), WTFMove(height), WTFMove(blur), WTFMove(c), WTFMove(m), WTFMove(y), WTFMove(k), WTFMove(a));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetShadow(ExecState* state)
{
    size_t argsCount = std::min<size_t>(8, state->argumentCount());
    if (argsCount == 3) {
        return jsCanvasRenderingContext2DPrototypeFunctionSetShadow1(state);
    }
    if (argsCount == 4) {
        JSValue distinguishingArg = state->uncheckedArgument(3);
        if (distinguishingArg.isUndefined())
            return jsCanvasRenderingContext2DPrototypeFunctionSetShadow1(state);
        if (distinguishingArg.isNumber())
            return jsCanvasRenderingContext2DPrototypeFunctionSetShadow2(state);
        return jsCanvasRenderingContext2DPrototypeFunctionSetShadow1(state);
    }
    if (argsCount == 5) {
        JSValue distinguishingArg = state->uncheckedArgument(3);
        if (distinguishingArg.isUndefined())
            return jsCanvasRenderingContext2DPrototypeFunctionSetShadow1(state);
        if (distinguishingArg.isNumber())
            return jsCanvasRenderingContext2DPrototypeFunctionSetShadow2(state);
        return jsCanvasRenderingContext2DPrototypeFunctionSetShadow1(state);
    }
    if (argsCount == 7) {
        return jsCanvasRenderingContext2DPrototypeFunctionSetShadow3(state);
    }
    if (argsCount == 8) {
        return jsCanvasRenderingContext2DPrototypeFunctionSetShadow4(state);
    }
    return argsCount < 3 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionPutImageData1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "putImageData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto imagedata = JSImageData::toWrapped(state->argument(0));
    if (UNLIKELY(!imagedata))
        return throwArgumentTypeError(*state, 0, "imagedata", "CanvasRenderingContext2D", "putImageData", "ImageData");
    auto dx = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dy = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.putImageData(*imagedata, WTFMove(dx), WTFMove(dy), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionPutImageData2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "putImageData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto imagedata = JSImageData::toWrapped(state->argument(0));
    if (UNLIKELY(!imagedata))
        return throwArgumentTypeError(*state, 0, "imagedata", "CanvasRenderingContext2D", "putImageData", "ImageData");
    auto dx = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dy = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dirtyX = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dirtyY = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dirtyWidth = convert<float>(*state, state->argument(5), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dirtyHeight = convert<float>(*state, state->argument(6), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.putImageData(*imagedata, WTFMove(dx), WTFMove(dy), WTFMove(dirtyX), WTFMove(dirtyY), WTFMove(dirtyWidth), WTFMove(dirtyHeight), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionPutImageData(ExecState* state)
{
    size_t argsCount = std::min<size_t>(7, state->argumentCount());
    if (argsCount == 3) {
        return jsCanvasRenderingContext2DPrototypeFunctionPutImageData1(state);
    }
    if (argsCount == 7) {
        return jsCanvasRenderingContext2DPrototypeFunctionPutImageData2(state);
    }
    return argsCount < 3 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "webkitPutImageDataHD");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto imagedata = JSImageData::toWrapped(state->argument(0));
    if (UNLIKELY(!imagedata))
        return throwArgumentTypeError(*state, 0, "imagedata", "CanvasRenderingContext2D", "webkitPutImageDataHD", "ImageData");
    auto dx = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dy = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.webkitPutImageDataHD(*imagedata, WTFMove(dx), WTFMove(dy), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "webkitPutImageDataHD");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto imagedata = JSImageData::toWrapped(state->argument(0));
    if (UNLIKELY(!imagedata))
        return throwArgumentTypeError(*state, 0, "imagedata", "CanvasRenderingContext2D", "webkitPutImageDataHD", "ImageData");
    auto dx = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dy = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dirtyX = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dirtyY = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dirtyWidth = convert<float>(*state, state->argument(5), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dirtyHeight = convert<float>(*state, state->argument(6), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.webkitPutImageDataHD(*imagedata, WTFMove(dx), WTFMove(dy), WTFMove(dirtyX), WTFMove(dirtyY), WTFMove(dirtyWidth), WTFMove(dirtyHeight), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD(ExecState* state)
{
    size_t argsCount = std::min<size_t>(7, state->argumentCount());
    if (argsCount == 3) {
        return jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD1(state);
    }
    if (argsCount == 7) {
        return jsCanvasRenderingContext2DPrototypeFunctionWebkitPutImageDataHD2(state);
    }
    return argsCount < 3 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionCreatePattern1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "createPattern");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto canvas = JSHTMLCanvasElement::toWrapped(state->argument(0));
    if (UNLIKELY(!canvas))
        return throwArgumentTypeError(*state, 0, "canvas", "CanvasRenderingContext2D", "createPattern", "HTMLCanvasElement");
    auto repetitionType = valueToStringTreatingNullAsEmptyString(state, state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.createPattern(*canvas, WTFMove(repetitionType), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionCreatePattern2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "createPattern");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto image = JSHTMLImageElement::toWrapped(state->argument(0));
    if (UNLIKELY(!image))
        return throwArgumentTypeError(*state, 0, "image", "CanvasRenderingContext2D", "createPattern", "HTMLImageElement");
    auto repetitionType = valueToStringTreatingNullAsEmptyString(state, state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.createPattern(*image, WTFMove(repetitionType), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

#if ENABLE(VIDEO)
static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionCreatePattern3(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "createPattern");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto video = JSHTMLVideoElement::toWrapped(state->argument(0));
    if (UNLIKELY(!video))
        return throwArgumentTypeError(*state, 0, "video", "CanvasRenderingContext2D", "createPattern", "HTMLVideoElement");
    auto repetitionType = valueToStringTreatingNullAsEmptyString(state, state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.createPattern(*video, WTFMove(repetitionType), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

#endif

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreatePattern(ExecState* state)
{
    size_t argsCount = std::min<size_t>(2, state->argumentCount());
    if (argsCount == 2) {
        JSValue distinguishingArg = state->uncheckedArgument(0);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLCanvasElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionCreatePattern1(state);
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLImageElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionCreatePattern2(state);
#if ENABLE(VIDEO)
        if (distinguishingArg.isObject() && asObject(distinguishingArg)->inherits(JSHTMLVideoElement::info()))
            return jsCanvasRenderingContext2DPrototypeFunctionCreatePattern3(state);
#endif
    }
    return argsCount < 2 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionCreateImageData1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "createImageData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    ImageData* imagedata = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        imagedata = JSImageData::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!imagedata))
            return throwArgumentTypeError(*state, 0, "imagedata", "CanvasRenderingContext2D", "createImageData", "ImageData");
    }
    JSValue result = toJS(state, castedThis->globalObject(), impl.createImageData(WTFMove(imagedata), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionCreateImageData2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "createImageData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto sw = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sh = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.createImageData(WTFMove(sw), WTFMove(sh), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionCreateImageData(ExecState* state)
{
    size_t argsCount = std::min<size_t>(2, state->argumentCount());
    if (argsCount == 1) {
        return jsCanvasRenderingContext2DPrototypeFunctionCreateImageData1(state);
    }
    if (argsCount == 2) {
        return jsCanvasRenderingContext2DPrototypeFunctionCreateImageData2(state);
    }
    return argsCount < 1 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionGetImageData(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "getImageData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto sx = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sy = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sw = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sh = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getImageData(WTFMove(sx), WTFMove(sy), WTFMove(sw), WTFMove(sh), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionWebkitGetImageDataHD(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "webkitGetImageDataHD");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto sx = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sy = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sw = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto sh = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::No);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.webkitGetImageDataHD(WTFMove(sx), WTFMove(sy), WTFMove(sw), WTFMove(sh), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawFocusIfNeeded");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    Element* element = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        element = JSElement::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!element))
            return throwArgumentTypeError(*state, 0, "element", "CanvasRenderingContext2D", "drawFocusIfNeeded", "Element");
    }
    impl.drawFocusIfNeeded(WTFMove(element));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawFocusIfNeeded");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto path = JSDOMPath::toWrapped(state->argument(0));
    if (UNLIKELY(!path))
        return throwArgumentTypeError(*state, 0, "path", "CanvasRenderingContext2D", "drawFocusIfNeeded", "DOMPath");
    Element* element = nullptr;
    if (!state->argument(1).isUndefinedOrNull()) {
        element = JSElement::toWrapped(state->uncheckedArgument(1));
        if (UNLIKELY(!element))
            return throwArgumentTypeError(*state, 1, "element", "CanvasRenderingContext2D", "drawFocusIfNeeded", "Element");
    }
    impl.drawFocusIfNeeded(*path, WTFMove(element));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded(ExecState* state)
{
    size_t argsCount = std::min<size_t>(2, state->argumentCount());
    if (argsCount == 1) {
        return jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded1(state);
    }
    if (argsCount == 2) {
        return jsCanvasRenderingContext2DPrototypeFunctionDrawFocusIfNeeded2(state);
    }
    return argsCount < 1 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawSystemFocusRing1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawSystemFocusRing");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    Element* element = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        element = JSElement::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!element))
            return throwArgumentTypeError(*state, 0, "element", "CanvasRenderingContext2D", "drawSystemFocusRing", "Element");
    }
    impl.drawSystemFocusRing(WTFMove(element));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsCanvasRenderingContext2DPrototypeFunctionDrawSystemFocusRing2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "drawSystemFocusRing");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto path = JSDOMPath::toWrapped(state->argument(0));
    if (UNLIKELY(!path))
        return throwArgumentTypeError(*state, 0, "path", "CanvasRenderingContext2D", "drawSystemFocusRing", "DOMPath");
    Element* element = nullptr;
    if (!state->argument(1).isUndefinedOrNull()) {
        element = JSElement::toWrapped(state->uncheckedArgument(1));
        if (UNLIKELY(!element))
            return throwArgumentTypeError(*state, 1, "element", "CanvasRenderingContext2D", "drawSystemFocusRing", "Element");
    }
    impl.drawSystemFocusRing(*path, WTFMove(element));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawSystemFocusRing(ExecState* state)
{
    size_t argsCount = std::min<size_t>(2, state->argumentCount());
    if (argsCount == 1) {
        return jsCanvasRenderingContext2DPrototypeFunctionDrawSystemFocusRing1(state);
    }
    if (argsCount == 2) {
        return jsCanvasRenderingContext2DPrototypeFunctionDrawSystemFocusRing2(state);
    }
    return argsCount < 1 ? throwVMError(state, createNotEnoughArgumentsError(state)) : throwVMTypeError(state);
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionClosePath(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "closePath");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    impl.closePath();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionMoveTo(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "moveTo");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto x = convert<double>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<double>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.moveTo(WTFMove(x), WTFMove(y));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionLineTo(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "lineTo");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto x = convert<double>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<double>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.lineTo(WTFMove(x), WTFMove(y));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionQuadraticCurveTo(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "quadraticCurveTo");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto cpx = convert<double>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto cpy = convert<double>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<double>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<double>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.quadraticCurveTo(WTFMove(cpx), WTFMove(cpy), WTFMove(x), WTFMove(y));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionBezierCurveTo(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "bezierCurveTo");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto cp1x = convert<double>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto cp1y = convert<double>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto cp2x = convert<double>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto cp2y = convert<double>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<double>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<double>(*state, state->argument(5), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.bezierCurveTo(WTFMove(cp1x), WTFMove(cp1y), WTFMove(cp2x), WTFMove(cp2y), WTFMove(x), WTFMove(y));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionArcTo(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "arcTo");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto x1 = convert<double>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y1 = convert<double>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x2 = convert<double>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y2 = convert<double>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto radius = convert<double>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.arcTo(WTFMove(x1), WTFMove(y1), WTFMove(x2), WTFMove(y2), WTFMove(radius), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionRect(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "rect");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto x = convert<double>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<double>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto w = convert<double>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto h = convert<double>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.rect(WTFMove(x), WTFMove(y), WTFMove(w), WTFMove(h));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionArc(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "arc");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto x = convert<double>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<double>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto radius = convert<double>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto startAngle = convert<double>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto endAngle = convert<double>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto anticlockwise = state->argument(5).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.arc(WTFMove(x), WTFMove(y), WTFMove(radius), WTFMove(startAngle), WTFMove(endAngle), WTFMove(anticlockwise), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionEllipse(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSCanvasRenderingContext2D*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "CanvasRenderingContext2D", "ellipse");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSCanvasRenderingContext2D::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto x = convert<double>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<double>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto radiusX = convert<double>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto radiusY = convert<double>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto rotation = convert<double>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto startAngle = convert<double>(*state, state->argument(5), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto endAngle = convert<double>(*state, state->argument(6), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto anticlockwise = state->argument(7).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.ellipse(WTFMove(x), WTFMove(y), WTFMove(radiusX), WTFMove(radiusY), WTFMove(rotation), WTFMove(startAngle), WTFMove(endAngle), WTFMove(anticlockwise), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}


}
